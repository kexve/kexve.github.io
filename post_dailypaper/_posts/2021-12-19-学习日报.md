---
layout: post 
title: 联邦学习twostage 
categories:  PaperRead   
---   

## Blockchain-enabled Server-less Federated Learning 区块链支持的无服务器联邦学习
### 摘要
我们专注于一个由区块链(BC)技术支持的异步无服务器FL解决方案。为了评估启用bc的FL的学习完成延迟，我们提出了一个基于批量服务队列理论的分析模型。此外，我们提供仿真结果来评估同步和异步机制的性能。正如我们的结果所示，同步设置比异步设置带来更高的预测精度。尽管如此，异步联邦优化在许多情况下提供了更低的延迟，因此在处理大数据集、严格的时间约束(例如，近实时应用程序)或变化很大的训练数据时，成为一个有吸引力的FL解决方案。
### 介绍
在本文中，我们解决了集中式FL方法所带来的问题，并提出采用无服务器的FL，即FL操作由无基础设施通信支持。更具体地说，我们专注于区块链(BC)技术，以增强分散的、无服务器的FL应用程序，它通过防篡改特性提供增强的安全性。BC已经在同步假设[11]下的FL应用程序中使用。然而，我们认为启用bc的无服务器FL方法自然适合异步操作，因为模型聚合是在新数据到达时执行的。

但是，将BC引入到网络应用程序中有详细说明的缺点[14]，包括可伸缩性、存储和安全性方面。为了阐明启用bc的FL方法的可行性，我们提供了一个分析模型来描述启用bc的FL端到端延迟。基于此模型，我们对同步和异步无BCenabled服务器的FL解决方案进行了深入的评估，并研究了每种方法在学习迭代时间和学习精度之间的权衡。同步解决方案提供了较高的学习准确性，而异步解决方案在大型异构部署中提供了及时的ML优化。在这方面，我们还展示了BC网络容量的重要性，这对于在FL端到端延迟上正确执行共识至关重要。

本文贡献：
1. 我们概述了使用BC来启用无服务器的FL应用程序(称为FLchain)，这允许消除在FL中协调学习操作的中央服务器的需要。同步(s-FLchain)和异步(a-FLchain)训练模式都进行了探索。
2. 我们开发了一个分析框架来推导与FLchain相关的端到端延迟，它可以应用于同步和异步设置。该框架的一个关键方面是用于度量BC系统中队列延迟的批服务队列模型，它对于捕获异步模型更新至关重要。
3. 我们研究了BC参数对无服务器FL端到端训练过程的影响。
4. 我们通过仿真分析了s-FLchain和aFLchain在学习精度和完成时间方面的性能。为此，我们使用著名的MNIST数据集进行手写字符识别。

### 相关
第一个用于进行无服务器FL的方法是基于绯闻算法[16]，它已经被应用于深度学习(DL)分布式训练，[17]取得了显著的成功。

flchain的概念首先是在[21]，[22]中提出的，其中BC被提议在块中存储模型更新，因此删除了中央服务器的图像。至于FLchain的实现，人们设想它可以运行在多种架构解决方案上，因此可以通过边缘计算[21]、雾计算[31]或点对点(P2P)通信[11]、[32]等范例来实现。

--- 2021-12-20 ---

此外，对于BC，生成大块(包括来自大量用户的信息)会导致BC的不稳定性，因为随着块传播时间增加[33]，分叉更有可能发生。因此，在单个块中包括许多同步的本地更新(就像在[11]、[34]中所做的那样)可能会随着参与FL节点数量的增加而导致严重的性能问题。

为了正确地捕获BC对FL的影响，需要对FLchain端到端延迟进行更深入的分析。

在本文中，我们开发了一个新的批处理服务队列模型来表征FLchain的延迟。区块链队列理论是最近在[40]中引入的一个新兴领域，紧随其后的是[41]、[42]、[43]中的方法。在批量服务队列中，数据包分批离开队列，而不是单独离开。此属性对于捕获BC中的事务生命周期非常有用，在服务(挖掘)之前收集这些事务生命周期。与批处理服务排队的现有文献不同，我们的模型描述了计时器和分叉。当计时器被用来保证挖掘块之间的最大时间间隔时，分叉是矿工使用的共识协议的直接结果。

## 正文主体
传统FL中，首先，采用分布式近似牛顿法对模型参数进行优化。但由于联邦平均(FedAvg)方法[44]对非凸问题的有效性和对同步随机梯度下降(SGD)通信开销的减少能力，它被广泛采用。

在这些场景中，数据集是异构的，客户机的可用性高度可变，或者异步提供更新[48]，[49]。在这种情况下，提供收敛证明是很有挑战性的，但是一些工作提倡通过互补的工具来加速性能，比如通过DL[46]估计丢失的本地更新。

### 区块链

![20211220111526](https://cdn.jsdelivr.net/gh/kexve/img/img/20211220111526.png)

一些最重要的共识协议是工作证明(PoW)[50]、权益证明(PoS)[51]、实用拜占庭容错(PBFT)[52]或Ripple[53]。在整个工作中，我们关注PoW，因为它提供了高水平的分权，并在大规模BC部署中提出了有趣的挑战。

### 区块链用于联邦学习

例如，在[11]中，本地FL模型更新包含在块中，稍后由单个设备聚合。相比之下，在[32]中，本地更新首先由矿工使用Gossip传播和预处理，然后在块中记录全局更新。

考虑到将BC集成到FL操作中，我们确定了以下迭代步骤，这些步骤是同步或异步执行的:
1. 本地计算:使用本地数据，每个客户端通过运行一定的优化机制(如SGD)来更新模型参数。
2. 收集交易:客户端生成的本地更新被发送给矿工，并传播到整个P2P网络。
3. 块生成:一旦收集了足够多的有效事务(由最大块大小决定)，或者如果超过了最大等待时间，则生成一个候选块进行挖掘。
4. 区块挖掘:一种共识机制(例如，解决一个谜题)被用来决定下一个要添加到BC的块。
5. 块传播:运行共识挖掘算法后，挖掘出的块在整个P2P网络中传播。
6. 全局模型聚合:使用包含在可接受块中的信息(即，局部模型更新)，导出全局模型更新。这一步可以在本地完成，也可以由具有足够计算能力的设备(例如，边缘服务器)完成。例如，在[11]，[32]中，每个客户端都自己更新全局模型，这与图3中的情况不同。
7. 块下载:客户端从最近的矿机下载最新的块，包含全局模型更新wt+1。

在**s-FLchain**中，全局模型最初由客户端下载，然后基于本地数据并行优化。一旦所有的本地更新被上传到BC网络，一个新的块被生成和挖掘。最新的块包含在一次新的迭代中用于更新全局模型的所有局部更新，因此需要调整块大小(SB)以适应所有这些更新。相反，在**a-FLchain**中，客户端执行本地计算并异步提交本地更新。当达到最大块大小(SB)时，或当预定义的等待计时器(τ)过期时，将生成一个新的块。

如前所述，区块大小是FLchain中的一个重要参数。正确地设置它可能会对BC的吞吐量产生很大的影响，从而影响FL的完成时间。特别是，块的大小越大，单个FL迭代中提供的信息质量就越高，但fork的概率和事务确认延迟就越大。优化最佳块大小是一项需要注意的复杂任务，因为它会在块传播延迟和分叉概率之间进行权衡。块大小的优化不在本文讨论范围内，留作以后的工作。

## 模型

