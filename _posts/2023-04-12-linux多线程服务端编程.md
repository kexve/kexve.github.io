---
layout: post
title: linux多线程服务端编程
categories: [多线程, c++]
---

## 线程安全的对象生命期管理

### 析构函数遇到多线程

c++ 要求程序员自己管理对象的生命期。这在多线程环境下显得尤为困难。当一个对象能被多个线程同时看到时，那么对象的销毁时机就会变得模糊不清，可能出现多种**竞态条件**。

> 试图以 **shared_ptr** 一劳永逸的解决这些问题。

#### 线程安全的定义

一个线程安全的 **class** 应该满足三个条件：

1. 多个线程同时访问时，其表现出正确的行为。
2. 无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织。
3. 调用端代码无需额外的同步或其他协调动作。

根据这个定义，c++标准库中的大多数 class 都不是线程安全的，包括 std::string, std::vector，因为这些 class 通常需要在外部加锁才能供多个线程同时访问。

#### MutexLock 与 MutexLockGuard

MutexLock 封装临界区,这是一个简单的资源类,用 RAII （Resource Acquisition Is Initialization）手法封装互斥器的创建与销毁.

MutexLockGuard封装临界区的进入和退出,即加锁和解锁. 它**在构造时获取锁，在析构时释放锁**，这样可以**确保线程在离开临界区时释放锁**。

一般情况下，我们创建mutex_lock_guard对象时会将其定义为栈上的局部变量，因为当变量超出作用域时，它会自动被销毁，从而自动释放锁。这样可以避免由于异常等情况导致锁未被正确释放而导致的死锁等问题。

