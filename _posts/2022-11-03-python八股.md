---
layout: post
title: python 一些奇怪的知识
categories: python
---

## python的语言特性：动态强类型
静/**动态**：编译/**运行 时**确定变量类型

弱/**强类型**：会/**不会**发生隐式类型转换

## python作为后端语言的优缺点
语言简单灵活，开发效率高

胶水语言，轮子多，拥有Django这种的成熟web框架

执行效率低，性能不如其他语言

动态语言，没有类型声明时就没有自动补全，而且很多问题要运行后才能发现

## 什么是duck type?
鸭子类型更关注对象的行为，只要实现了某种接口方法就行，而不在乎是什么类型

比如说定义了 __iter__魔法方法的类实例对象都可以用for来迭代

## 魔法方法
Python 的对象天生拥有一些神奇的方法，它们总被双下划线所包围，他们是面向对象的 Python 的一切。

他们是可以给你的类增加魔力的特殊方法，如果你的对象实现（重载）了这些方法中的某一个，那么这个方法就会在特殊的情况下被 Python 所调用，你可以定义自己想要的行为，而这一切都是自动发生的。

### 构造和初始化

每个人都知道一个最基本的魔术方法， __init__ 。通过此方法我们可以定义一个对象的初始操作。然而，当我调用 x = SomeClass() 的时候， __init__ 并不是第一个被调用的方法。实际上，还有一个叫做 __new__ 的方法，来构造这个实例。然后给在开始创建时候的初始化函数来传递参数。在对象生命周期的另一端，也有一个 __del__ 方法。我们现在来近距离的看一看这三个方法:

__new__(cls, [...) __new__ 是在一个对象实例化的时候所调用的第一个方法。它的第一个参数是这个类，其他的参数是用来直接传递给 __init__ 方法。 __new__ 方法相当不常用,但是它有自己的特性，特别是当继承一个不可变的类型比如一个tuple或者string。我不希望在 __new__ 上有太多细节，因为并不是很有用处，但是在 Python文档 中有详细的阐述。

__init__(self, […) 此方法为类的初始化方法。当构造函数被调用的时候的任何参数都将会传给它。(比如如果我们调用 x = SomeClass(10, 'foo'))，那么 __init__ 将会得到两个参数10和foo。 __init__ 在Python的类定义中被广泛用到。

__del__(self) 如果 __new__ 和 __init__ 是对象的构造器的话，那么 __del__ 就是析构器。它不实现语句 del x (以上代码将不会翻译为 x.__del__() )。它定义的是当一个对象进行垃圾回收时候的行为。当一个对象在删除的时需要更多的清洁工作的时候此方法会很有用，比如套接字对象或者是文件对象。注意，如果解释器退出的时候对象还存存在，就不能保证 __del__ 能够被执行，所以 __del__ can’t serve as a replacement for good coding practices ()~~~~~~~

放在一起的话，这里是一个 __init__ 和 __del__ 实际使用的例子。
```python
from os.path import join

class FileObject:
    '''给文件对象进行包装从而确认在删除时文件流关闭'''

    def __init__(self, filepath='~', filename='sample.txt'):
        #读写模式打开一个文件
        self.file = open(join(filepath, filename), 'r+')

    def __del__(self):
        self.file.close()
        del self.file
```

### 让定制的类工作起来
使用Python的魔术方法的最大优势在于他们提供了一种简单的方法来让对象可以表现的像内置类型一样。那意味着你可以避免丑陋的，违反直觉的，不标准的的操作方法。在一些语言中，有一些操作很常用比如：
```python
if instance.equals(other_instance):
    # do something
```
在Python中你可以这样。但是这会让人迷惑且产生不必要的冗余。相同的操作因为不同的库会使用不同的名字，这样会产生不必要的工作。然而有了魔术方法的力量，我们可以定义一个方法(本例中为 __eq__ )，就说明了我们的意思：
```
if instance == other_instance:
        #do something
```
这只是魔术方法的功能的一小部分。它让你可以定义符号的含义所以我们可以在我们的类中使用。就像内置类型一样。

## 什么是monkey patch?
monkey patch就是运行时替换对象，本质上是对象的重新赋值

## py3和py2的区别
print在py3里是一个函数，在py2里只是一个关键字

py3文件的默认编码是utf8，py2文件的默认编码是ascii

py3的str是unicode字符串，而py2的str是bytes

py3的range()返回一个可迭代对象，py2的 range()返回一个列表，xrange()返回一个可迭代对象,

py3的除法返回float，py2的除法返回int

## 可变对象与不可变对象
可变对象: list，dict，set

不可变对象: bool，int，float，tuple，str…

## 函数传递中*args，**kwargs
用来处理可变参数，接收参数后，**args会变成一个tuple，kwargs会变成一个dict**

## 什么时候需要捕获异常?
Django的ORM框架操作数据库时，获取数据，更新数据等都有可能会异常

socket通信时，recv()方法可能会因为对方突然中断连接导致异常

## 什么是CPython GIL?
GIL，Global Interpreter Lock，即全局解释器锁

引入GIL是因为CPython的内存管理并不是线程安全的,

为了保护多线程下对python对象的访问，每个线程在执行过程中都需要先获取GIL，保证同一时刻只有一个线程在执行代码

GIL使得python的多线程不能充分发挥多核CPU的性能，对CPU密集型程序的影响较大

## 什么是生成器?
生成器是一种可迭代对象，可以挂起并保持当前的状态

生成器遇到yield处会停止执行，调用next()或send()才会继续执行

定义一个生成器有两种方式，一种是生成器推导式，一种是在普通函数中添加yield语句并实例化

## yield 使用

## 浅拷贝和深拷贝
浅拷贝出来的是一个独立的对象，但它的子对象还是原对象中的子对象

深拷贝会递归地拷贝原对象中的每一个子对象，因此拷贝后的对象和原对象互不相关。

## 迭代器与可迭代对象的区别
可迭代对象类，必须自定义__iter__()魔法方法，range，list类的实例化对象都是可迭代对象

迭代器类，必须自定义__iter__()和__next__()魔法方法，用iter()函数可以创建可迭代对象的迭代器

## 闭包
闭包就是一个嵌套函数，它的内部函数 使用了 外部函数的变量或参数,它的外部函数 返回了 内部函数

可以保存外部函数内的变量，不会随着外部函数调用完而销毁

## python垃圾回收机制
引用计数为主，标记清除 和 分代回收为辅

引用计数机制是这样的

当对象被创建，被引用，作为参数传递，存储到容器中，引用计数+1

当对象离开作用域，引用指向别的对象，del，从容器中移除，引用计数-1

当引用计数降为0，python就会自动回收该对象所在的内存空间，

但是引用计数无法解决循环引用的问题，所以引入了标记清除和分代回收机制

## async和await的作用
async: 声明一个函数为异步函数，函数内只要有await就要声明为async

await: 搭配asyncio.sleep()时会切换协程，当切换回来后再继续执行下面的语句

## 内置的数据结构和算法
内置数据结构: list，dict，tuple，set

内置算法: sorted，max

## collections模块
collections模块提供了一些好用的容器数据类型，其中常用的有: namedtuple，deque，Counter，OrderedDict，defaultdict

## 为什么dict查找的时间复杂度是O(1)?
dict底层是哈希表，哈希表类似于C语言的数组，可以实现按索引随机访问

但dict的key不一定是整数，需要先通过哈希函数，再经过取余操作转换为索引

## list tuple的底层结构
list和tuple底层都是顺序表结构

list底层是可变数组，数组里存放的是元素对象的指针

## set的底层结构
哈希表，key就是元素，value都是空

## class方法 和 static方法的区别
class方法的第一个参数是cls，可以访问类属性，类方法

static方法和普通函数一样，只不过是放在类里，要通过类或实例来调用，但是它不能访问类和实例的属性和方法

## 什么是装饰器?
装饰器是一个接收函数作为参数的闭包函数

它可以在不修改函数内部源代码的情况下，给函数添加额外的功能

```python
import time

def calc_time(func):
    def inner():
        t1 = time.time()
        func()
        t2 = time.time()
        print('cost time: {}s'.format(t2-t1))
    return inner
```

## 什么是元类? 使用场景
元类是创建类的类，type还有继承自type的类都是元类

作用: 在类定义时（new, init）和 类实例化时(call) 可以添加自定义的功能

使用场景: ORM框架中创建一个类就代表数据库中的一个表，但是定义这个类时为了统一需要把里面的类属性全部改为小写，这个时候就要用元类重写new方法，把attrs字典里的key转为小写

## 实现单例模式的三种方式
单例模式: 一个类只能创建一个实例化对象

```python
class Foo():
    __instance = None

    def __new__(cls):
        if cls.__instance is None:
            cls.__instance = super().__new__(cls)
        return cls.__instance
```
```python
class MyType(type):
    def __init__(self):
        super().__init__()
        self.__instance = None

    def __call__(self，*args，**kwargs):
        if not self.__instance:
            self.__instance = super().__call__(*args，**kwargs)
        return self.__instance
    
class Foo(metaclass=MyType):
    ...
```
```python
def outter(cls):
    dct = {}
    def inner(*args，**kwargs):
        if cls not in dct:
            dct[cls] = cls(*args，**kwargs)
        return dct[cls]
    return inner

@outter
class Foo():
    ...
```

## 工厂模式
根据不同条件创建不同的类实例化对象

```python
class CarFactory():
    def produce(self，name):
        if name == 'BYD':
            return BYD()
        elif name == 'BMW':
            return BMW()
        
class BYD():
    pass
    
class BMW():
    pass

car = CarFactory().produce('BMW')
```