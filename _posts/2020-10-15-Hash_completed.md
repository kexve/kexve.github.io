---  
layout: post  
title: Hash函数  
categories: 数据结构  
---  
@@dt
## 什么是 Hash
@@ds
在某种程度上，散列是与排序相反的一种操作，排序是将集合中的元素按照某种方式比如字典顺序排列在一起，而散列通过计算哈希值，<strong><font color=blue>打破元素之间原有的关系，使集合中的元素按照散列函数的分类进行排列。</font></strong>  
@@dc
@@dt
## 为什么要有 Hash
@@ds
我们通常使用数组或者链表来存储元素，一旦存储的内容数量特别多，需要占用很大的空间，而且在查找某个元素是否存在的过程中，数组和链表都需要挨个循环比较，<strong><font color=blue>而通过哈希计算，可以大大减少比较次数。</font></strong>  
哈希 其实是随机存储的一种优化，先进行分类，然后查找时按照这个对象的分类去找。  
@@dc
@@dt
## 几种常见的哈希函数构造方法
@@ds
@@dt
### 直接定址法
@@ds
取关键字或关键字的某个线性函数值为散列地址. H(key)=key或H(key)=a\*key+b  
@@dc
@@dt
### 除留余数法
@@ds
取关键字不大于散列表长度m的数p求余, 得到的数作为散列地址. H(key)=key%p, p<m  
@@dc
@@dt
### 构造原则
@@ds
尽可能少的产生冲突  
@@dc
@@dc
@@dt
## 冲突解决
@@ds
@@dt
### 链接法(拉链法)
@@ds
<strong><font color=blue>将所有关键字为同义词的结点链接在同一个单链表中。</font></strong>  
![Image](https://s3.jpg.cm/2020/10/15/tylpR.png)
@@dc
@@dt
### 开放地址法
@@ds
用开放定址法解决冲突的做法是：当冲突发生时，<strong><font color=blue>使用某种探测技术在散列表中形成一个探测序列。</font></strong>沿此序列逐个单元地查找，直到找到给定的关键字，或者碰到一个开放的地址（即该地址单元为空）为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。查找时探测到开放的地址则表明表中无待查的关键字，即查找失败。  
@@dt
#### 线性探查法
@@ds
Hi = (h(key)+i) % m, 0 <= i <= m-1  
探查时从地址 d 开始，首先探查 T[d]，然后依次探查 T[d+1]，…，直到 T[m-1]，此后又循环到 T[0]，T[1]，…，直到探查到 有空余地址 或者到 T[d-1]为止。  
@@dc
@@dt
#### 二次探查法
@@ds
hi = (h(key)+i*i) % m, 0 <= i <= m-1  
探查时从地址 d 开始，首先探查 T[d]，然后依次探查 T[d+1^2]，T[d+2^2]，T[d+3^2],…，等，直到探查到 有空余地址 或者到 T[d-1]为止。  
@@dc
@@dt
#### 双重散列法
@@ds
hi=(h(key)+i*h1(key)) % m, 0 <= i <= m-1  
探查时从地址 d 开始，首先探查 T[d]，然后依次探查 T[d+h1(d)], T[d + 2*h1(d)]，…，等。该方法使用了两个散列函数 h(key) 和 h1(key)，故也称为双散列函数探查法。  
@@dc
@@dt
#### 构造原则
@@ds
定义 h1(key) 的方法较多，但无论采用什么方法定义，都必须使 h1(key) 的值和 m 互素，才能使发生冲突的同义词地址均匀地分布在整个表中，否则可能造成同义词地址的循环计算。  

@@dc
@@dc
@@dc
