---
layout: post
title: 秒杀系统
categories: [面试, 高并发, 电商项目]
---

## 总览

![20230307114144](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230307114144.png)

## 秒杀系统架构图

![20230307114901](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230307114901.png)

## 秒杀流程图

![20230307114934](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230307114934.png)

## 秒杀系统设计

![20230307114955](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230307114955.png)

## 瞬时高并发

瞬时高并发是秒杀项目的典型问题，常规的架构设计和代码实现在一般活动中可以应对，但是却经受不住瞬时高并发的考验。

### 秒杀业务的场景

1. 预抢购业务：活动未正式开始前，先进行活动预约。在真正秒杀的时间点，很多数据都是预处理好的了，可以很程度削减系统压力。比如：活动预约、订金预约、火车票预约等
2. 分批抢购业务：分时段多场次抢购，比如我们熟悉的京东满减优惠券就是分场次开放的，整点抢购。
3. 实时秒杀：这是最有难度的秒杀场景，比如双 11 晚上 0 点秒杀，在这个时间点前后会涌入高并发流量：频繁刷新页面、疯狂点击抢购按钮、甚至利用机器模拟请求。

下面就按照思维导图的顺序，为大家展开聊聊如何做好秒杀系统的设计？

## 活动页面

活动页面是用户流量的第一入口，是并发量最大的地方。

如果这些流量都直接访问服务端，服务端会因为承受不住这么大的压力，而直接挂掉。

![20230307115451](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230307115451.png)

活动页面绝大多数内容是固定的，比如：商品名称、商品描述、图片等。

为了减少不必要的服务端请求，通常情况下，会**对活动页面做静态化处理**。

因为**用户浏览商品等常规操作，并不会请求到服务端。只有到了秒杀时间点，并且用户主动点了秒杀按钮才允许访问服务端。**

![20230307115501](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230307115501.png)

## CDN

更进一步，只做页面静态化还不够，因为用户分布在全国各地，有些人在北京，有些人在上海，有些人在深圳，地域相差很远，网速各不相同。

如何才能让用户最快访问到活动页面呢？

这就需要使用 CDN，它的全称是 Content Delivery Network，即**内容分发网络**。

**使用户能够就近获取所需内容，提高用户访问活动页面的响应速度和命中率**。

![20230307115854](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230307115854.png)

## 秒杀按钮

如果你也参与过秒杀活动，应该有这样的体会：因为担心错过秒杀时间，会提前进入活动页面，并且不断的刷新页面。

很多秒杀活动在活动开始前，秒杀按钮是置灰，不可点击的。只有到了秒杀时间点那一时刻，秒杀按钮才会自动点亮，变成可点击的。

往往在秒杀开始之前，很多用户已经迫不及待了，通过不停刷新页面，争取在第一时间看到秒杀按钮的点亮。

大家思考一个问题：这个**活动页面是静态的，我们在静态页面中如何控制秒杀按钮，只在秒杀时间点时才点亮呢？**

答案就是：使用 **js 文件控制**。

为了性能考虑，我们一般会将 css、js 和图片等静态资源文件提前缓存到 CDN 上，让用户能够就近访问秒杀页面。

### 更新 CDN

我们还要考虑一个问题：CDN 上的 js 文件要如何更新呢？

![20230307120118](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230307120118.png)

我们可以通过在 js 中设置标记的方式来设置按钮的状态，比如 isBegin=true 代表活动开始，isBegin=false 代表活动未开始。

秒杀开始之前，**js 标志为 false，秒杀活动开始时设置为 true。为了达到这个效果，我们另外还需要一个随机参数用来主动刷新 CDN。**

当秒杀开始的时候系统会生成一个新的 js 文件，此时标志为 true，并且随机参数生成一个新值，然后同步给 CDN。由于**有了这个随机参数，CDN 不会缓存数据，每次都能从 CDN 中获取最新的 js 代码。**

### 前端骚操作

除了使用 CDN 降低请求压力，**前端还可以加一个定时器，控制请求频率**，比如：10 秒之内，只允许发起一次请求。

如果用户点击了一次秒杀按钮，则在 10 秒之内置灰，不允许再次点击，等到过了时间限制，又允许重新点击该按钮。

## 读多写少

**秒杀是非常典型的“读多写少”场景。**

在秒杀的过程中，系统一般会先查一下库存是否足够，如果库存充足才允许下单，写数据库。如果不够，则直接返回该商品已经抢完。

由于大量用户抢少量商品，只有极少部分用户能够抢成功，所以绝大部分用户在秒杀时，库存其实是不足的，系统会直接返回该商品已经抢完。

如果有数十万的请求过来，并发请求数据库查库存是否足够，此时数据库可能会挂掉。

因为**数据库的连接资源非常有限，MySQL 这类关系型数据库是无法同时支持这么多的连接。**

那怎么办呢？

**我们应该使用 nosql 缓存，比如：redis。**

![20230307132838](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230307132838.png)

注意：即便用了 redis，在高并发场景下也需要部署多个节点。

## 缓存

通常情况下，我们需要在 redis 中保存商品信息，包括：商品 id、商品名称、规格属性、库存等信息，同时数据库中也要有相关信息，毕竟缓存并不完全可靠。

用户在点击秒杀按钮，请求秒杀接口的过程中，传入的商品 id 参数，服务端需要校验该商品是否合法。

大致流程如下图所示：

![20230307133314](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230307133314.png)

1. 根据商品 id，先从缓存中查询商品，如果商品存在，则参与秒杀。
2. 如果不存在，则需要从数据库中查询商品：
3. 如果存在，则将商品信息放入缓存，然后参与秒杀。
4. 如果商品不存在，则直接提示失败。

这个过程表面上看起来是 OK 的，但是如果深入分析，会发现一些问题。

为了方便大家理解，也科普一下缓存常用问题：

![20230307133516](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230307133516.png)

### 缓存击穿

比如商品 A 第一次秒杀时，缓存中是没有数据的，但数据库中有。虽说上面有从数据库中查到数据，放入缓存的逻辑。

但是在高并发下，同一时刻会有大量的请求，都在秒杀同一件商品，这些请求同时去查缓存没有命中，然后又同时访问数据库。结果悲剧了，数据库可能扛不住压力，直接挂掉。

如何解决这个问题呢？

这就**需要加锁，最好使用分布式锁**，思路见下图：

![20230307133618](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230307133618.png)

#### 预热

针对这种情况，我们**最好在项目启动之前，先把缓存进行预热**。

事先把参与秒杀的所有商品，同步到缓存中，这样商品基本都能直接从缓存中获取到，就不会出现缓存击穿的问题了。

是不是上面加锁这一步可以不需要了？

#### 双保险

表面上看起来，确实可以不需要。但是真实环境是比较复杂的，我们要考虑到意外情况，比如：

1. 缓存中设置的过期时间不对，缓存提前过期了

2. 或者缓存被不小心删除了

3. 或者缓存设置的时间过短，在秒杀活动结束前同时到期了

如果不加锁，上面这些情况很可能出现缓存击穿的问题。

活动数据预缓存+分布式锁，相当于上了双保险。

### 缓存穿透

> 在流量大时，可能 DB 就挂掉了，要是有人利用不存在的 key 频繁攻击我们的应用，这就是漏洞。
> 如发起为 id 为“-1”的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。

如果**有大量的请求传入商品 id，并且在缓存和数据库中都*不存在*，这些请求就都会穿透过缓存，而直接访问数据库了**。这就是典型的缓存穿透。

如果没有加锁的话很可能造成服务不可用。

由于前面已经加了锁，所以即使这里的并发量很大，也不会导致数据库直接挂掉。但很显然这些请求的处理性能并不好。

有没有更好的解决方案？

**布隆过滤器你值得拥有**

简单来说，布隆过滤器（BloomFilter）是一种数据结构。特点是存在性检测，**如果布隆过滤器中不存在，那么实际数据一定不存在；如果布隆过滤器中存在，实际数据不一定存在。**相比于传统数据结构（如：List、Set、Map 等）来说，它更高效，占用空间更少。缺点是它对于存在的判断是具有概率性。

![20230307134057](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230307134057.png)

引入布隆过滤器后的流程如下：

1. 系统根据商品 id，先从布隆过滤器中查询该 id 是否存在
2. 如果存在则允许从缓存中查询数据
3. 如果不存在，则直接返回失败。

#### 数据一致性

虽说该方案可以解决缓存穿透问题，但是又会引出另外一个问题：**布隆过滤器中的数据如何跟缓存中的数据保持一致？**

这就要求，如果缓存中数据有更新，就要及时同步到布隆过滤器中。

如果数据同步失败了，还需要增加重试机制，而且跨数据源，能保证数据的实时一致性吗？

显然是不能的。

#### 应用场景

**布隆过滤器建议使用在缓存数据更新很少的场景中。**

如果缓存数据更新非常频繁，又该如何处理呢？

#### 巧妙的设计

**我们可以把不存在的商品 id 也缓存起来。**

下次，再有该商品 id 的请求过来，则也能从缓存中查到数据，只不过该数据比较特殊，表示商品不存在。 需要特别注意的是，这种特殊缓存设置的超时时间应该尽量短一点。

### 缓存雪崩

描述：

缓存雪崩是指**缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至 down 机**。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。

解决方案：

1. 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
2. 如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。
3. 设置热点数据永远不过期。
