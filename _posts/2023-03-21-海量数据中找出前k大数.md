---
layout: post
title: 海量数据中找出前k大数
categories: [面试, 数据结构]
---

## 有 1 亿个浮点数，如果找出期中最大的 10000 个？

该题目解法有很多，以下逐个阐述

### 全部排序

最容易想到的方法是将数据全部排序，然后在排序后的集合中进行查找，最快的排序算法的时间复杂度一般为 O（nlogn），如快速排序。**但是在 32 位的机器上，每个 float 类型占 4 个字节，1 亿个浮点数就要占用 400MB 的存储空间，对于一些可用内存小于 400M 的计算机而言**，很显然是不能一次将全部数据读入内存进行排序的。其实即使内存能够满足要求（我机器内存都是 8GB），该方法也并不高效，因为题目的目的是寻找出最大的 10000 个数即可，而排序却是将所有的元素都排序了，做了很多的无用功。

### 局部淘汰

第二种方法为局部淘汰法，该方法与排序方法类似，用一个容器保存前 10000 个数，然后将剩余的所有数字——与容器内的最小数字相比，如果所有后续的元素都比容器内的 10000 个数还小，那么容器内这个 10000 个数就是最大 10000 个数。如果某一后续元素比容器内最小数字大，则删掉容器内最小元素，并将该元素插入容器，最后遍历完这 1 亿个数，得到的结果容器中保存的数即为最终结果了。此时的时间复杂度为 O（n+m^2），其中 m 为容器的大小，即 10000。

### 分治法

第三种方法是分治法，将 1 亿个数据分成 100 份，每份 100 万个数据，找到每份数据中最大的 10000 个，最后在剩下的 100X10000 个数据里面找出最大的 10000 个。如果 100 万数据选择足够理想，那么可以过滤掉 1 亿数据里面 99%的数据。100 万个数据里面查找最大的 10000 个数据的方法如下：用**快速排序**的方法，将数据分为 2 堆，如果大的那堆个数 N 大于 10000 个，继续对大堆快速排序一次分成 2 堆，如果大的那堆个数 N 大于 10000 个，继续对大堆快速排序一次分成 2 堆，如果大堆个数 N 小于 10000 个，就在小的那堆里面快速排序一次，找第 10000-n 大的数字；递归以上过程，就可以找到第 1w 大的数。参考上面的找出第 1w 大数字，就可以类似的方法找到前 10000 大数字了。此种方法需要每次的内存空间为 10^6\*4=4MB，一共需要 101 次这样的比较。

### 哈希法

第四种方法是 Hash 法。如果这 1 亿个书里面有很多重复的数，先通过 Hash 法，把这 1 亿个数字去重复，这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间，然后通过分治法或最小堆法查找最大的 10000 个数。

### 小顶堆

第五种方法采用小顶堆。首先读入前 10000 个数来创建大小为 10000 的最小堆，建堆的时间复杂度为 O（mlogm）（m 为数组的大小即为 10000），然后遍历后续的数字，并于堆顶（最小）数字进行比较。如果比最小的数小，则继续读取后续数字；如果比堆顶数字大，则替换堆顶元素并重新调整堆为最小堆。整个过程直至 1 亿个数全部遍历完为止。然后按照中序遍历的方式输出当前堆中的所有 10000 个数字。该算法的时间复杂度为 O（nmlogm），空间复杂度是 10000（常数）。

小顶堆可以参照前面的堆排序，解决 top k 问题是堆排序算法的一种延伸。
对于该种算法，假设一共是 n 个数，找前 m 个大的。第一次建堆并调整的时间大约为 mlog(m)，那么对于剩下的每个元素，最坏的情况下就是每个都调整堆，堆调整一次的时间复杂度为 log(m)，所以总的时间复杂度为（n-m）log(m) + mlog(m) = nlog(m)

小顶堆的方法是最直观的解决 top k 问题的方法，还有一种更为高效的方法：Quick Select 算法。

### Quick Select 算法

Quick Select 脱胎于快速排序（Quick Sort），两个算法的作者都是 Hoare，并且思想也非常接近：选取一个基准元素 pivot，将数组切分（partition）为两个子数组，比 pivot 大的扔左子数组，比 pivot 小的扔右子数组，然后递推地切分子数组。**Quick Select 不同于 Quick Sort 的是其没有对每个子数组做切分，而是对目标子数组做切分。**其次，Quick Select 与 Quick Sort 一样，是一个不稳定的算法；pivot 选取直接影响了算法的好坏，**worst case 下的时间复杂度达到了 O(n2)**。

Quick Select 的目标是找出第 k 大元素，所以

若切分后的左子数组的长度 > k，则第 k 大元素必出现在左子数组中；
若切分后的左子数组的长度 = k-1，则第 k 大元素为 pivot；
若上述两个条件均不满足，则第 k 大元素必出现在右子数组中。

```c
//Kth Largest Element in an Array
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        int l=0,r=nums.size()-1;
        k=nums.size()-k;
        while(l<=r){
            int index = partition(nums,l,r);
            if(index==k)
                return nums[index];
            else if(index<k)
                l = index+1;
            else
                r = index-1;
        }
        return 0;
    }
    int partition(vector<int>& nums, int start, int end)
    {
        if(start==end)
            return start;
        int pivot = nums[end];
        while(start<end){
            while(start<end && nums[start]<=pivot) ++start;
            nums[end]=nums[start];
            while(start<end && nums[end]>=pivot) --end;
            nums[start]=nums[end];
        }
        nums[end]=pivot;
        return end;
    }
};
```
