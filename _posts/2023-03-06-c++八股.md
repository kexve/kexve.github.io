---
layout: post
title: c++ 八股
categories: 面试
---

## C++ 中的四种智能指针

说⼀下为什么要使⽤智能指针：**智能指针其作⽤是管理⼀个指针**，避免程序员申请的空间。在函数结束时忘记释放，造成内存泄漏这种情况滴发⽣。

因为智能指针就是⼀个类，当超出了类的作⽤域是，类会⾃动调⽤析构函数，析构函数会⾃动释放资源。

1. auto_ptr（C++98 的⽅案， C11 已抛弃）采⽤*所有权模式*

   ```c++
   auto_ptr<std::string> p1 (new string ("hello"));
   auto_ptr<std::string> p2;
   p2 = p1; //auto_ptr 不会报错.
   ```

   此时不会报错， p2 剥夺了 p1 的所有权，但是当程序运⾏时访问 p1 将会报错。所以 auto_ptr 的缺点是：存在潜在的内存崩溃问题！

2. unique_ptr （替换 auto_ptr ）

   unique_ptr 实现独占式拥有或严格拥有概念，保证同⼀时间内只有⼀个智能指针可以指向该对象。它对于避免资源泄露特别有⽤。
   采⽤所有权模式，还是上⾯那个例⼦

   ```c++
   unique_ptr<string> p3 (new string (auto));//#4
   unique_ptr<string> p4； //#5
   p4 = p3;//此时会报错
   ```

   编译器认为 p4=p3 ⾮法，避免了 p3 不再指向有效数据的问题。因此， unique_ptr ⽐ auto_ptr 更安全。

3. shared_ptr（共享型，强引⽤）

   shared_ptr 实现共享式拥有概念，**多个智能指针可以指向相同对象，该对象和其相关资源会在“最后⼀个引⽤被销毁”时候释放**。从名字 share 就可以看出了资源可以被多个指针共享，它使⽤计数机制来表明资源被⼏个指针共享。可以通过成员函数 use_count() 来查看资源的所有者个数，除了可以通过 new 来构造，还可以通过传⼊ auto_ptr,unique_ptr,weak_ptr 来构造。当我们调⽤ release() 时，当前指针会释放资源所有权，计数减⼀。当计数等于 0 时，资源会被释放。

4. weak_ptr（弱引⽤）

   weak_ptr 是⼀种不控制对象⽣命周期的智能指针，它指向⼀个 shared_ptr 管理的对象。进⾏该对象的内存管理的是那个强引⽤的 shared_ptr。weak_ptr 只是提供了对管理对象的⼀个访问⼿段。 weak_ptr 设计的⽬的是为配合 shared_ptr ⽽引⼊的⼀种智能指针来协助 shared_ptr ⼯作，它只可以从⼀个 shared_ptr 或另⼀个 weak_ptr 对象构造,**它的构造和析构不会引起引⽤记数的增加或减少**。

   **weak_ptr 是⽤来解决 shared_ptr 相互引⽤时的死锁问题，如果说两个 shared_ptr 相互引⽤，那么这两个指针的引⽤计数永远不可能下降为 0，也就是资源永远不会释放**。它是对对象的⼀种弱引⽤，不会增加对象的引⽤计数，和 shared_ptr 之间可以相互转化， shared_ptr 可以直接赋值给它，它可以通过调⽤ lock 函数来获得 shared_ptr。

   当两个智能指针都是 shared_ptr 类型的时候，析构时两个资源引⽤计数会减⼀，但是两者引⽤计数还是为 1，导致跳出函数时资源没有被释放（的析构函数没有被调⽤），解决办法：把其中⼀个改为 weak_ptr 就可以。

滥用智能指针会把你的代码污染.

确定持有者 :使用 unique_ptr

不需要持有对象 or 解决互相强引用 :使用 weak_ptr

需要共享时 :使用 shared

无主对象,与 C 交互,传递可能为空的对象,传递需要修改的对象:指针

传递不能为 nullptr 的对象:引用,const 引用

---

嗯，大家都在说普通指针和智能指针，少说了一个“引用”

先考虑用引用和值，减少 90%的指针，特别是函数之间，基本上没有必要传指针。

再考虑使用 unique_ptr，替换类的成员不能用引用的情况下使用指针。

最后考虑使用 share_ptr/weak_ptr，解决生命周期复杂到一个类管不了的情况。

最后才是合理的指针使用场景。

## C++ 中内存分配情况

栈：由**编译器**管理分配和回收，存放**局部变量和函数参数**。

堆：由**程序员**管理，需要⼿动 new malloc delete free 进⾏分配和回收，空间较⼤，但可能会出现内存泄漏和空闲碎⽚的情况。

全局/静态存储区：分为初始化和未初始化两个相邻区域，存储初始化和未初始化的全局变量和静态变量。**编译期⼀般不分配内存，放在符号表中以提⾼访问效率.**

常量存储区：存储常量，⼀般不允许修改。

代码区：存放程序的⼆进制代码。

## C++ 中的指针参数传递和引⽤参数传递

**指针参数传递本质上是值传递，它所传递的是⼀个地址值**。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从⽽形成了实参的⼀个副本（替身）。
值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进⾏的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。
**引⽤参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址**。被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。
**引⽤传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的⼀个局部变量，但是任何对于引⽤参数的处理都会通过⼀个间接寻址的⽅式操作到主调函数中的相关变量。⽽对于指针传递的参数，如果改变被调函数中的指针地址，它将应⽤不到主调函数的相关变量。**如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使⽤指向指针的指针或者指针引⽤。
从编译的⻆度来讲，程序在编译时分别将指针和引⽤添加到符号表上，符号表中记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为**指针变量的地址值**，⽽引⽤在符号表上对应的地址值为**引⽤对象的地址值**（与实参名字不同，地址相同）。符号表⽣成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），⽽引⽤对象则不能修改。

值传递： 形参是实参的拷⻉，函数内部对形参的操作并不会影响到外部的实参。

指针传递： 也是值传递的⼀种⽅式，形参是指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进
⾏操作。

引⽤传递： 实际上就是把引⽤对象的地址放在了开辟的栈空间中，函数内部对形参的任何操作可以直接映射到外部
的实参上⾯。

---

引用的规则：

（1）引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。

（2）不能有 NULL 引用，引用必须与合法的存储单元关联（指针则可以是 NULL）。

（3）一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。

## 指针数组和数组指针

指针数组

指针数组：指针数组可以说成是”指针的数组”，首先这个变量是一个数组。

其次，”指针”修饰这个数组，意思是说这个数组的所有元素都是指针类型。

在 32 位系统中，指针占四个字节。

数组指针

数组指针：数组指针可以说成是”数组的指针”，首先这个变量是一个指针。

其次，”数组”修饰这个指针，意思是说这个指针存放着一个数组的首地址，或者说这个指针指向一个数组的首地址。

根据上面的解释，可以了解到指针数组和数组指针的区别，因为二者根本就是种类型的变量。

## C++ 中 const 和 static 关键字（定义，⽤途）

static 作⽤：控制变量的存储⽅式和可⻅性。

作⽤⼀：修饰局部变量：⼀般情况下，对于局部变量在程序中是存放在栈区的，并且局部的⽣命周期在包含语句块执⾏结束时便结束了。**但是如果⽤ static 关键字修饰的话，该变量便会存放在静态数据区，其⽣命周期会⼀直延续到整个程序执⾏结束。**但是要注意的是，虽然⽤ static 对局部变量进⾏修饰之后，其⽣命周期以及存储空间发⽣了变化，**_但其作⽤域并没有改变，作⽤域还是限制在其语句块_**。

作⽤⼆：修饰全局变量：对于⼀个全局变量，它既可以在本⽂件中被访问到，也可以在同⼀个⼯程中其它源⽂件被访问(添加 extern 进⾏声明即可)。**⽤ static 对全局变量进⾏修饰改变了其作⽤域范围，由原来的整个⼯程可⻅变成了本⽂件可⻅。**

作⽤三：修饰函数：⽤ static 修饰函数，情况和修饰全局变量类似，也是改变了函数的作⽤域。

作⽤四：修饰类：如果 C++ 中对类中的某个函数⽤ static 修饰，则表示该函数属于⼀个类⽽不是属于此类的任何特定对象；如果对类中的某个变量进⾏ static 修饰，则表示该变量以及所有的对象所有，存储空间中只存在⼀个副本，可以通过；类和对象去调⽤。（补充：静态⾮常量数据成员，其只能在类外定义和初始化，在类内仅是声明⽽已。）

作⽤五：类成员/类函数声明 static 函数体内 static 变量的作⽤范围为该函数体，不同于 auto 变量，该变量的内存只被分配⼀次，因此其值在下次调⽤时仍维持上次的值；在模块内的 static 全局变量可以被模块内所⽤函数访问，但不能被模块外其它函数访问；在模块内的 static 函数只可被这⼀模块内的其它函数调⽤，这个函数的使⽤范围被限制在声明它的模块内；在类中的 static 成员变量属于整个类所拥有，对类的所有对象只有⼀份拷⻉；在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因⽽只能访问类的 static 成员变量。**static 类对象必须要在类外进⾏初始化， static 修饰的变量先于对象存在，所以 static 修饰的变量要在类外初始化**；由于 static **修饰的类成员属于类，不属于对象，因此 static 类成员函数是没有 this 指针， this 指针是指向本对象的指针，正因为没有 this 指针，所以 static 类成员函数不能访问⾮ static 的类成员**，只能访问 static 修饰的类成员；

static 成员函数不能被 virtual 修饰， static 成员不属于任何对象或实例，所以加上 virtual 没有任何实际意义；静态成员函数没有 this 指针，**虚函数的实现是为每⼀个对象分配⼀个 vptr 指针，⽽ vptr 是通过 this 指针调⽤的**，所以不能为 virtual；虚函数的调⽤关系， this->vptr->ctable->virtual function。

---

const 关键字：含义及实现机制 const 修饰基本类型数据类型：基本数据类型，修饰符 const 可以⽤在类型说明符前，也可以⽤在类型说明符后，其结果是⼀样的。在使⽤这些常量的时候，只要不改变这些常量的值即可。

const 修饰指针变量和引⽤变量：如果 const 位于⼩星星的左侧，则 const 就是⽤来修饰指针所指向的变量，即指针指向为常量；如果 const 位于⼩星星的右侧，则 const 就是修饰指针本身，即指针本身是常量。

const 应⽤到函数中：作为参数的 const 修饰符：调⽤函数的时候，⽤相应的变量初始化 const 常量，则在函数体中，按照 const 所修饰的部分进⾏常量化，保护了原对象的属性。 [注意]：参数 const 通常⽤于参数为指针或引⽤的情况; 作为函数返回值的 const 修饰符：声明了返回值后， const 按照"修饰原则"进⾏修饰，起到相应的保护作⽤。

const 在类中的⽤法： **const 成员变量，只在某个对象⽣命周期内是常量，⽽对于整个类⽽⾔是可以改变的。因为类可以创建多个对象，不同的对象其 const 数据成员值可以不同。**所以不能在类的声明中初始化 const 数据成员，因为类的对象在没有创建时候，编译器不知道 const 数据成员的值是什么。 const 数据成员的初始化只能在类的构造函数的初始化列表中进⾏。 const 成员函数： const 成员函数的主要⽬的是防⽌成员函数修改对象的内容。要注意， **const 关键字和 static 关键字对于成员函数来说是不能同时使⽤的，因为 static 关键字修饰静态成员函数不含有 this 指针，即不能实例化， const 成员函数⼜必须具体到某⼀个函数**。

const 修饰类对象，定义常量对象：常量对象只能调⽤常量函数，别的成员函数都不能调⽤。

补充： *const 成员函数中如果实在想修改某个变量，可以使⽤ mutable 进⾏修饰。*成员变量中如果想建⽴在整个类中都恒定的常量，应该⽤类中的枚举常量来实现或者 static const。

```c++
// 在C++中，只有被声明为const的成员函数才能被一个const类对象调用。

// 要声明一个const类型的类成员函数，只需要在成员函数参数列表后加上关键字const，例如，

class Screen {
public:
   char get() const;
};
// 在类体之外定义const成员函数时，还必须加上const关键字，例如

char Screen::get() const {
   return _screen[_cursor];
}
// 若将成员成员函数声明为const，则该函数不允许修改类的数据成员。例如，

class Screen {
public:
    int ok() const {return _cursor; }
    int error(intival) const { _cursor = ival; }
};
// 在上面成员函数的定义中，ok()的定义是合法的，error()的定义则非法。
```

### C ++ 中的 const 类成员函数（⽤法和意义）

**常量对象可以调⽤类中的 const 成员函数，但不能调⽤⾮ const 成员函数；** （原因：对象调⽤成员函数时，在形参列表的最前⾯加⼀个形参 this，但这是隐式的。 this 指针是默认指向调⽤函数的当前对象的，所以，很⾃然，this 是⼀个常量指针 test * const，因为不可以修改 this 指针代表的地址。但当成员函数的参数列表（即⼩括号）后加了 const 关键字（void print() const;），此成员函数为常量成员函数，此时它的隐式 this 形参为 const test *const，即不可以通过 this 指针来改变指向对象的值。**⾮常量对象可以调⽤类中的 const 成员函数，也可以调⽤⾮ const 成员函数。**

## C 和 C++ 区别 （函数/类/struct/class）

⾸先， C 和 C++ 在基本语句上没有过⼤的区别。

C++ 有新增的语法和关键字，**语法的区别有头⽂件的不同和命名空间的不同**， C++ 允许我们⾃⼰定义⾃⼰的空间，C 中不可以。关键字⽅⾯⽐如 C++ 与 C 动态管理内存的⽅式不同， C++ 中在 malloc 和 free 的基础上增加了 new 和 delete，⽽且 C++ 中在指针的基础上增加了引⽤的概念，**关键字例如 C++中还增加了 auto， explicit 体现显示和隐式转换上的概念要求，还有 dynamic_cast 增加类型安全⽅⾯的内容**。

函数⽅⾯ C++ 中有**重载和虚函数**的概念： C++ ⽀持函数重载⽽ C 不⽀持，是因为 C++ 函数的名字修饰与 C 不同，C++ 函数名字的修饰会将参数加在后⾯，例如， int func(int,double)经过名字修饰之后会变成\_func_int_double，⽽ C 中则会变成 \_func，所以 C++ 中会⽀持不同参数调⽤不同函数。

C++ 还有**_虚函数概念，⽤以实现多态_**。类⽅⾯， C 的 struct 和 C++ 的类也有很⼤不同： C++ 中的 struct 不仅可以有成员变量还可以成员函数，⽽且**对于 struct 增加了权限访问的概念**， struct 的默认成员访问权限和默认继承权限都是 public， C++ 中除了 struct 还有 class 表示类， struct 和 class 还有⼀点不同在于 class 的默认成员访问权限和默认继承权限都是 private。

C++ 中增加了**模板**还重⽤代码，提供了更加**强⼤的 STL 标准库**。

最后补充⼀点就是 C 是⼀种结构化的语⾔，重点在于算法和数据结构。 C 程序的设计⾸先考虑的是如何通过⼀个代码，⼀个过程对输⼊进⾏运算处理输出。⽽ C++ ⾸先考虑的是如何构造⼀个对象模型，让这个模型能够契合与之对应的问题领域，这样就能通过获取对象的状态信息得到输出。C 的 struct 更适合看成是⼀个**数据结构**的实现体，⽽ C++ 的 class 更适合看成是⼀个**对象**的实现体。

## C++ 和 Java 区别（语⾔特性，垃圾回收，应⽤场景等）

**指针**： Java 语⾔让程序员没法找到指针来直接访问内存，没有指针的概念，并有内存的⾃动管理功能，从⽽有效的防⽌了 C++ 语⾔中的指针操作失误的影响。但**并⾮ Java 中没有指针， Java 虚拟机内部中还是⽤了指针，保证了 Java 程序的安全**。

**多重继承**： C++ ⽀持多重继承但 Java 不⽀持，但⽀持⼀个类继承多个接⼝，实现 C++ 中多重继承的功能，⼜避免了 C++ 的多重继承带来的不便。

数据类型和类： **Java 是完全⾯向对象的语⾔，所有的函数和变量必须是类的⼀部分。除了基本数据类型之外，其余的都作为类对象，对象将数据和⽅法结合起来，把它们封装在类中，这样每个对象都可以实现⾃⼰的特点和⾏为**。Java 中取消了 C++ 中的 struct 和 union 。

**⾃动内存管理**： Java 程序中所有对象都是⽤ new 操作符建⽴在内存堆栈上， Java ⾃动进⾏⽆⽤内存回收操作，不需要程序员进⾏⼿动删除。⽽ C++ 中必须由程序员释放内存资源，增加了程序设计者的负担。 Java 中当⼀个对象不再被⽤到时， ⽆⽤内存回收器将给他们加上标签。 Java ⾥⽆⽤内存回收程序是以线程⽅式在后台运⾏的，利⽤空闲时间⼯作来删除。

**Java 不⽀持操作符重载**。操作符重载被认为是 C++ 的突出特性。

**Java 不⽀持预处理功能**。 C++ 在编译过程中都有⼀个预编译阶段， Java 没有预处理器，但它提供了 import 与 C++预处理器具有类似功能。

类型转换： C++ 中有**数据类型隐含转换的机制**， Java 中需要限时强制类型转换。字符串： C++中字符串是以 Null 终⽌符代表字符串的结束，⽽ Java 的字符串 是⽤类对象（string 和 stringBuffer）来实现的。

Java 中**不提供 goto 语句**，虽然指定 goto 作为关键字，但不⽀持它的使⽤，使程序简洁易读。

**Java 的异常机制⽤于捕获例外事件**，增强系统容错能⼒。

## C++ 中重载和重写，重定义的区别

### overload 重载

是指**同作用域内**被声明的⼏个具有不同参数列表的同名函数，依赖于 C++函数名字的修饰会将参数加在后⾯，可以是参数类型，个数，顺序的不同。根据参数列表决定调⽤哪个函数，重载不关⼼函数的返回类型。

### Overriding Function (重写，也称覆盖)：

C++中，派生类重新定义一个与基类的**虚函数**完全一样的成员函数，称为重写。这里的**完全一样指函数名、参数列表、返回值，甚至是 const 限定词都需一致，所以称为重写（覆盖）**。

只有虚函数（virtual function）能够被重写。

### Redefining functions 重定义基类中的函数

当**派生类**中有与**基类**同名的函数，即为重定义。但是**基类派生类中的这两个同名函数的参数列表不一定要不同，可以相同**。

## 虚函数与多态

重载被认为不是多态，**多态是运行时动态绑定（“一种接口多种实现”）**，如果硬要认为重载是多态，它顶多是编译时“多态”。

## 介绍 C++ 所有的构造函数

类的对象被创建时，编译系统为对象分配内存空间，并⾃动调⽤构造函数，由构造函数完成成员的初始化⼯作。即构造函数的作⽤：初始化对象的数据成员。

1. ⽆参数构造函数： 即默认构造函数，如果没有明确写出⽆参数构造函数，编译器会⾃动⽣成默认的⽆参数构造函数，函数为空，什么也不做，如果不想使⽤⾃动⽣成的⽆参构造函数，必需要⾃⼰显示写出⼀个⽆参构造函数。

2. ⼀般构造函数： 也称重载构造函数，⼀般构造函数可以有各种参数形式，⼀个类可以有多个⼀般构造函数，前提是参数的个数或者类型不同，创建对象时根据传⼊参数不同调⽤不同的构造函数。

3. 拷⻉构造函数： 拷⻉构造函数的函数参数为对象本身的引⽤，⽤于根据⼀个已存在的对象复制出⼀个新的该类的对象，⼀般在函数中会将已存在的对象的数据成员的值⼀⼀复制到新创建的对象中。如果没有显示的写拷⻉构造函数，则系统会默认创建⼀个拷⻉构造函数，但当类中有指针成员时，最好不要使⽤编译器提供的默认的拷⻉构造函数，最好⾃⼰定义并且在函数中执⾏深拷⻉。

4. 类型转换构造函数： 根据⼀个指定类型的对象创建⼀个本类的对象，也可以算是⼀般构造函数的⼀种，这⾥提出来，是想说有的时候不允许默认转换的话，要记得将其声明为 explict 的，来阻⽌⼀些隐式转换的发⽣。

5. 赋值运算符的重载：注意，这个类似拷⻉构造函数，将＝右边的本类对象的值复制给＝左边的对象，它不属于构造函数，＝左右两边的对象必需已经被创建。如果没有显示的写赋值运算符的重载，系统也会⽣成默认的赋值运算符，做⼀些基本的拷⻉⼯作。

这⾥区分

```c++
A a1, A a2; a1 = a2;//调⽤赋值运算符
A a3 = a1;//调⽤拷⻉构造函数，因为进⾏的是初始化⼯作， a3 并未存在
```

## C++ 的四种强制转换

C++ 的四种强制转换包括： static_cast, dynamic_cast, const_cast, reinterpret_cast

1. static_cast：**明确指出类型转换**，⼀般建议将隐式转换都替换成显示转换，**因为没有动态类型检查，上⾏转换（派⽣类->基类）安全，下⾏转换（基类->派⽣类） 不安全**，所以主要执⾏⾮多态的转换操作；

2. dynamic_cast：**专⻔⽤于派⽣类之间的转换**， type-id 必须**是类指针，类引⽤或 void\*，对于下⾏转换是安全的，当类型不⼀致时，转换过来的是空指针**，⽽ static_cast，当类型不⼀致时，转换过来的事错误意义的指针，可能造成⾮法访问等问题。

3. const_cast：专⻔⽤于 const 属性的转换，去除 const 性质，或增加 const 性质， 是四个转换符中唯⼀⼀个可以操作常量的转换符。

4. reinterpret_cast：不到万不得已，不要使⽤这个转换符，⾼危操作。使⽤特点： 从底层对数据进⾏重新解
   释，依赖具体的平台，可移植性差； 可以将整形转 换为指针，也可以把指针转换为数组；可以在指针和引⽤
   之间进⾏肆⽆忌惮的转换。

## 野(wild)指针与悬空(dangling)指针有什么区别？如何避免？

野指针(wild pointer)：就是没有被初始化过的指针。⽤ gcc -Wall 编译, 会出现 used uninitialized 警告。

悬空指针：是指针最初指向的内存已经被释放了的⼀种指针。

⽆论是野指针还是悬空指针，都是指向⽆效内存区域(这⾥的⽆效指的是"不安全不可控")的指针。 访问"不安全可
控"(invalid)的内存区域将导致"Undefined Behavior"。

如何避免使⽤野指针？ 在平时的编码中，养成在定义指针后且在使⽤之前完成初始化的习惯或者使⽤智能指针。

## 说⼀下 const 修饰指针如何区分？

下⾯都是合法的声明，但是含义⼤不同：

const int \* p1; //指向整形常量 的指针，它指向的值不能修改

int \* const p2; //指向整形的常量指针 ，它不能在指向别的变量，但指向（变量）的值可以修改。

const int \*const p3; //指向整形常量 的 常量指针 。它既不能再指向别的常量，指向的值也不能修改。

理解这些声明的技巧在于，**查看关键字 const 右边来确定什么被声明为常量 ，如果该关键字的右边是类型，则值是常量；如果关键字的右边是指针变量，则指针本身是常量。**

## 简单说⼀下函数指针

从定义和⽤途两⽅⾯来说⼀下⾃⼰的理解：

⾸先是定义：函数指针是指向函数的指针变量。函数指针本身⾸先是⼀个指针变量，该指针变量指向⼀个具体的函数。这正如⽤指针变量可指向整型变量、字符型、数组⼀样，这⾥是指向函数。

在编译时，**每⼀个函数都有⼀个⼊⼝地址，该⼊⼝地址就是函数指针所指向的地址。**有了指向函数的指针变量后，可⽤该指针变量调⽤函数，就如同⽤指针变量可引⽤其他类型变量⼀样，在这些概念上是⼤体⼀致的。

其次是⽤途：调⽤函数和做函数的参数，⽐如回调函数。

```c++
char * fun(char * p) {…} // 函数fun
char * (*pf)(char * p); // 函数指针pf
pf = fun; // 函数指针pf指向函数fun
pf(p); // 通过函数指针pf调⽤函数fun
```

## 堆和栈的区别

### 栈

由编译器进⾏管理，在需要时**由编译器⾃动分配空间，在不需要时候⾃动回收空间，⼀般保存的是局部变量和函数参数等。**

**连续的内存空间**，在函数调⽤的时候，⾸先⼊栈的主函数的下⼀条可执⾏指令的地址，然后是函数的各个参数。

char _ fun(char _ p) {…} // 函数 fun

char * (*pf)(char \* p); // 函数指针 pf

pf = fun; // 函数指针 pf 指向函数 fun

pf(p); // 通过函数指针 pf 调⽤函数 fun ⼤多数编译器中，**参数是从右向左⼊栈**（原因在于采⽤这种顺序，是为了让程序员在使⽤ C/C++的“函数参数⻓度可变”这个特性时更⽅便。如果是从左向右压栈，第⼀个参数（即描述可变参数表各变量类型的那个参数）将被放在栈底，由于可变参的函数第⼀步就需要解析可变参数表的各参数类型，即第⼀步就需要得到上述参数，因此，将它
放在栈底是很不⽅便的。）本次函数调⽤结束时，局部变量先出栈，然后是参数，最后是栈顶指针最开始存放的地址，程序由该点继续运⾏，**不会产⽣碎⽚**。

栈是⾼地址向低地址扩展，栈低⾼地址，空间较⼩

### 堆

由程序员管理，需要⼿动 new malloc delete free 进⾏分配和回收，如果不进⾏回收的话，会造成内存泄漏的问题。

**不连续的空间**，实际上系统中有⼀个**空闲链表**，当有程序申请的时候，系统遍历空闲链表找到第⼀个⼤于等于申请
⼤⼩的空间分配给程序，⼀般在分配程序的时候，也会空间头部写⼊内存⼤⼩，⽅便 delete 回收空间⼤⼩。当然
如果有剩余的，也会将剩余的插⼊到空闲链表中，这也是**产⽣内存碎⽚**的原因。

堆是低地址向⾼地址扩展，空间较⼤，较为灵活。

## new / delete，malloc / free 的区别

为什么有了 malloc／ free 还需要 new／ delete？ 因为对于⾮内部数据类型⽽⾔，光⽤ malloc／ free ⽆法满⾜动
态对象的要求。对象在创建的同时需要⾃动执⾏构造函数，对象在消亡以前要⾃动执⾏析构函数。由于 mallo／
free 是库函数⽽不是运算符，不在编译器控制权限之内，不能够把执⾏的构造函数和析构函数的任务强加于
malloc／ free，所以有了 new／ delete 操作符。

## volatile 和 extern 关键字

### volatile 三个特性

**- 保证变量的内存可见性 - 禁止指令重排序**

这说明这个 volatile 关键字发挥了它的作用。其实不只是内嵌汇编操纵栈"这种方式属于编译无法识别的变量改变，另外更多的可能是多线程并发访问共享变量时，一个线程改变了变量的值，怎样让改变后的值对其它线程 visible。一般说来，volatile 用在如下的几个地方：

1. 中断服务程序中修改的供其它程序检测的变量需要加 volatile；

2. 多任务环境下各任务间共享的标志应该加 volatile；

3. 存储器映射的硬件寄存器通常也要加 volatile 说明，因为每次对它的读写都可能由不同意义；

### extern

在 C 语⾔中，修饰符 extern ⽤在变量或者函数的声明前，⽤来说明 “此变量/函数是在别处定义的，要在此处引⽤”。

注意 extern 声明的位置对其作⽤域也有关系，如果是在 main 函数中进⾏声明的，则只能在 main 函数中调⽤，在其它函数中不能调⽤。其实要调⽤其它⽂件中的函数和变量，只需把该⽂件⽤ #include 包含进来即可，**为啥要⽤ extern？因为⽤ extern 会加速程序的编译过程，这样能节省时间。**

其次，看看在未加 extern "C" 声明时，是如何连接的。

假设在 C++ 中，模块 A 的头文件如下：

```c++
//模块A头文件　moduleA.h
#ifndef MODULE_A_H
#define MODULE_A_H
int foo( int x, int y );
#endif
```

在模块 B 中引用该函数：

```c++
// 模块B实现文件　moduleB.cpp
#include "moduleA.h"
foo(2,3);
```

实际上，在连接阶段，连接器会从模块 A 生成的目标文件 moduleA.obj 中寻找 \_foo_int_int 这样的符号！

对于上面例子，如果 B 模块是 C 程序，而 A 模块是 C++ 库头文件的话，会导致链接错误；同理，如果 B 模块是 C++ 程序，而 A 模块是 C 库的头文件也会导致错误。

再者，看看加 extern "C" 声明后的编译和连接方式
加 extern "C" 声明后，模块 A 的头文件变为：

```c
// 模块A头文件　moduleA.h
#ifndef MODULE_A_H
#define MODULE_A_H
extern "C" int foo( int x, int y );
#endif
```

在模块 B 的实现文件中仍然调用 foo( 2,3 ) ，其结果，将会是 C 语言的编译连接方式：模块 A 编译生成 foo 的目标代码时，没有对其名字进行特殊处理，采用了 C 语言的方式；连接器在为模块 B 的目标代码寻找 foo(2,3) 调用时，寻找的是未经修改的符号名 \_foo 。

## define 和 const 区别（编译阶段、安全性、内存占⽤等）

对于 define 来说， 宏定义实际上是在预编译阶段进⾏处理，没有类型，也就没有类型检查，仅仅做的是遇到宏定义进⾏字符串的展开，遇到多少次就展开多少次，⽽且这个简单的展开过程中，很容易出现边界效应，达不到预期的效果。因为 define 宏定义仅仅是展开，因此运⾏时系统并不为宏定义分配内存，但是从汇编 的⻆度来讲，define 却以⽴即数的⽅式保留了多份数据的拷⻉。

对于 const 来说， const 是在编译期间进⾏处理的， const 有类型，也有类型检查，程序运⾏时系统会为 const 常量分配内存，⽽且从汇编的⻆度讲， const 常量在出现的地⽅保留的是真正数据的内存地址，只保留了⼀份数据的拷⻉，省去了不必要的内存空间。⽽且，有时编译器不会为普通的 const 常量分配内存，⽽是直接将 const 常量添加到符号表中，省去了读取和写⼊内存的操作，效率更⾼。

## 计算下⾯⼏个类的⼤⼩

```c
class A{}; sizeof(A) = 1; //空类在实例化时得到⼀个独⼀⽆⼆的地址，所以为 1.
class A{virtual Fun(){} }; sizeof(A) = 4(32bit)/8(64bit) //当 C++ 类中有虚函数的时候，会有⼀
个指向虚函数表的指针（vptr）
class A{static int a; }; sizeof(A) = 1;
class A{int a; }; sizeof(A) = 4;
class A{static int a; int b; }; sizeof(A) = 4;
```

## 结构体内存对⻬⽅式和为什么要进⾏内存对⻬？

⾸先我们来说⼀下结构体中内存对⻬的规则：

对于结构体中的各个成员，第⼀个成员位于偏移为 0 的位置，以后的每个数据成员的偏移量必须是
min(#pragma pack() 制定的数，数据成员本身⻓度) 的倍数。

在所有的数据成员完成各⾃对⻬之后，结构体或联合体本身也要进⾏对⻬，整体⻓度是 min(#pragma pack()
制定的数，⻓度最⻓的数据成员的⻓度) 的倍数。那么内存对⻬的作⽤是什么呢？

经过内存对⻬之后， CPU 的内存访问速度⼤⼤提升。因为 CPU 把内存当成是⼀块⼀块的，块的⼤⼩可以是
2， 4， 8， 16 个字节，因此 CPU 在读取内存的时候是⼀块⼀块进⾏读取的，块的⼤⼩称为内存读取粒度。⽐
如说 CPU 要读取⼀个 4 个字节的数据到寄存器中（假设内存读取粒度是 4），如果数据是从 0 字节开始的，
那么直接将 0-3 四个字节完全读取到寄存器中进⾏处理即可。

如果数据是从 1 字节开始的，就⾸先要将前 4 个字节读取到寄存器，并再次读取 4-7 个字节数据进⼊寄存
器，接着把 0 字节， 5， 6， 7 字节的数据剔除，最后合并 1， 2， 3， 4 字节的数据进⼊寄存器，所以说，当内
存没有对⻬时，寄存器进⾏了很多额外的操作，⼤⼤降低了 CPU 的性能。

另外，还有⼀个就是，有的 CPU 遇到未进⾏内存对⻬的处理直接拒绝处理，不是所有的硬件平台都能访问任
意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。所以内存
对⻬还有利于平台移植。

## 内存泄漏的定义，如何检测与避免？

### 定义

内存泄漏简单的说就是申请了⼀块内存空间，使⽤完毕后没有释放掉。 它的⼀般表现⽅式是程序运⾏时间越⻓，占⽤内存越多，最终⽤尽全部内存，整个系统崩溃。由程序申请的⼀块内存，且没有任何⼀个指针指向它，那么这块内存就泄漏了。

### 如何检测内存泄漏

⾸先可以通过观察猜测是否可能发⽣内存泄漏， Linux 中使⽤ swap 命令观察还有多少可⽤的交换空间，在⼀
两分钟内键⼊该命令三到四次，看看可⽤的交换区是否在减少。

还可以使⽤ 其他⼀些 /usr/bin/stat ⼯具如 netstat、 vmstat 等。如发现波段有内存被分配且从不释放，⼀个
可能的解释就是有个进程出现了内存泄漏。

当然也有⽤于内存调试，内存泄漏检测以及性能分析的软件开发⼯具 valgrind 这样的⼯具来进⾏内存泄漏的
检测。
