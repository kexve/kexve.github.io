---
layout: post
title: 词法分析器 c++ 实现尝试
categories: python
---

## 保留字表、界符运算符、标识符（Token）的定义

```c++
//保留字表
static char reserveWord[32][20] = {"auto",     "break",  "case",     "char",   "const",    "continue", "default",
                                   "do",       "double", "else",     "enum",   "extern",   "float",    "for",
                                   "goto",     "if",     "int",      "long",   "register", "return",   "short",
                                   "signed",   "sizeof", "static",   "struct", "switch",   "typedef",  "union",
                                   "unsigned", "void",   "volatile", "while"};

//界符运算符
static char operatorOrDelimiter[36][10] = {"+", "-",  "*",  "/", "<",  "<=", ">", ">=", "=",  "==", "!=", ";",
                                           "(", ")",  "^",  ",", "\"", "\'", "#", "&",  "&&", "|",  "||", "%",
                                           "~", "<<", ">>", "[", "]",  "{",  "}", "\\", ".",  "\?", ":",  "!"};

//标识符表
static char IDentifierTbl[1000][50] = {""};
```

## 数字、字母或下划线、保留字的判断

```c++
bool isDigit(char ch) //判断是否为数字
{
    if (ch >= '0' && ch <= '9')
        return true;
    return false;
}

bool isLetter(char ch) //判断是否为字母或下划线
{
    if ((ch >= 'a' && ch <= 'z') || (ch <= 'Z' && ch >= 'A') || ch == '_')
        return true;
    return false;
}

int isReserve(char *s) //判断是否为保留字
{
    for (int i = 0; i < 32; ++i)
    {
        if (strcmp(reserveWord[i], s) == 0)
            return i + 1; //返回种别码
    }
    return -1;
}
```

## 源程序预处理，过滤注释和换行回车制表符

```c++
void filter(char *s, int len) //源程序预处理，过滤注释和换行回车制表符
{
    char tmp[10000];
    int p = 0;
    for (int i = 0; i < len; ++i)
    {
        if (s[i] == '/' && s[i + 1] == '/') //单行注释
        {
            while (s[i] != '\n')
                ++i; //扫描到换行符为止
        }
        if (s[i] == '/' && s[i + 1] == '*') //多行注释
        {
            i += 2;
            while (s[i] != '*' && s[i + 1] != '/')
            {
                if (s[i] == '\0')
                {
                    std::cout << "annotation error!" << std::endl;
                    exit(0);
                }
                i++;
            }
            i += 2;
        }
        if (s[i] != '\n' && s[i] != '\t' && s[i] != '\v' && s[i] != '\r')
        {
            tmp[p] = s[i];
            ++p;
        }
    }
    tmp[p] = '\0';
    strcpy(s, tmp);
}
```

## 扫描源程序

```c++
void scanner(int &syn, char *project, char *token,
             int &p) //扫描源程序，syn是种别码，token是当前扫描的单词，p为扫描位置索引
{
    int count = 0;
    char ch;
    ch = project[p];
    while (ch == ' ') //去掉空格
    {
        ++p;
        ch = project[p];
    }
    for (int i = 0; i < 20; i++) //清空token
    {
        token[i] = '\0';
    }
    if (isLetter(project[p]))
    { //以字母开头
        token[count++] = project[p++];
        while (isLetter(project[p]) || isDigit(project[p])) //后面是字母或数字
        {
            token[count++] = project[p++];
        }
        token[count] = '\0';
        syn = isReserve(token); //查表找到种别码
        if (syn == -1)
        {              //若不是保留字则是标识符
            syn = 100; //标识符种别码
        }
        return;
    }
    else if (isDigit(project[p]))
    { //以数字开头
        token[count++] = project[p++];
        while (isDigit(project[p])) //后面是数字
        {
            token[count++] = project[p++];
        }
        token[count] = '\0';
        syn = 99;
        return;
    }
    else if (ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == ';' || ch == '(' || ch == ')' || ch == '^' ||
             ch == ',' || ch == '\"' || ch == '\'' || ch == '~' || ch == '#' || ch == '%' || ch == '[' || ch == ']' ||
             ch == '{' || ch == '}' || ch == '\\' || ch == '.' || ch == '\?' || ch == ':')
    {
        token[count++] = project[p++];
        token[count] = '\0';
        for (int i = 0; i < 36; ++i)
        {
            if (strcmp(operatorOrDelimiter[i], token) == 0)
            {
                syn = 33 + i;
                break;
            }
        }
        return;
    }
    else if (ch == '<')
    { //可能是< <= <<
        ++p;
        if (project[p] == '=') //<=
        {
            syn = 38;
        }
        if (project[p] == '<') //<<
        {
            syn = 58;
        }
        else //<
        {
            --p;
            syn = 37;
        }
        ++p;
        return;
    }
    else if (ch == '>')
    { //可能是> >= >>
        ++p;
        if (project[p] == '=') //>=
        {
            syn = 40;
        }
        if (project[p] == '>') //>>
        {
            syn = 59;
        }
        else //>
        {
            --p;
            syn = 39;
        }
        ++p;
        return;
    }
    else if (ch == '=')
    { //可能是= ==
        ++p;
        if (project[p] == '=') //==
        {
            syn = 42;
        }
        else
        { //=
            --p;
            syn = 41;
        }
        ++p;
        return;
    }
    else if (ch == '!')
    { //可能是! !=
        ++p;
        if (project[p] == '=') //==
        {
            syn = 43;
        }
        else
        {
            --p;
            syn = 68;
        }
        ++p;
        return;
    }
    else if (ch == '&')
    { //可能是& &&
        ++p;
        if (project[p] == '&') //&&
        {
            syn = 53;
        }
        else
        { //&
            --p;
            syn = 52;
        }
        ++p;
        return;
    }
    else if (ch == '|')
    { //可能是| ||
        ++p;
        if (project[p] == '|') //||
        {
            syn = 55;
        }
        else
        {
            --p;
            syn = 54;
        }
        ++p;
        return;
    }
    else if (ch == '\0')
    { //文件结束
        syn = 0;
    }
    else
    {
        std::cout << "wrong letter:" << ch << std::endl;
        exit(0);
    }
}
```

## 入口函数

```c++
int main()
{
    //打开一个文件，读取源程序
    char project[10000];
    char token[20] = {0};
    int syn = -1;
    int p = 0; //程序位置索引
    std::ifstream in("test.txt");
    std::ofstream out("out.txt");
    if (!in.is_open())
    {
        std::cout << "error opening file!" << std::endl;
        exit(0);
    }
    while (!in.eof())
    {
        in.get(project[p++]);
    }
    project[p++] = '\0';
    in.close();
    std::cout << "源程序为:\n" << project << std::endl;
    filter(project, p);
    std::cout << "过滤后的源程序为:\n" << project << std::endl;
    p = 0;
    while (syn != 0)
    { //开始扫描
        scanner(syn, project, token, p);
        if (syn == 100)
        { //标识符
            for (int i = 0; i < 1000; i++)
            { //插入标识符表
                if (strcmp(IDentifierTbl[i], token) == 0)
                { //已存在表中
                    break;
                }
                else if (strcmp(IDentifierTbl[i], "") == 0)
                {
                    strcpy(IDentifierTbl[i], token);
                    break;
                }
            }
            std::cout << "标识符:" << token << std::endl;
            out << "标识符:" << token << std::endl;
        }
        else if (syn == 99) //常数
        {
            std::cout << "常数:" << token << std::endl;
            out << "常数:" << token << std::endl;
        }
        else if (syn <= 32 && syn >= 1) //保留字
        {
            std::cout << reserveWord[syn - 1] << ":" << syn << std::endl;
            out << reserveWord[syn - 1] << ":" << syn << std::endl;
        }
        else if (syn >= 33 && syn <= 68) //运算符或界符
        {
            std::cout << operatorOrDelimiter[syn - 33] << ":" << syn << std::endl;
            out << operatorOrDelimiter[syn - 33] << ":" << syn << std::endl;
        }
    }
    out.close();
    system("pause");
}
```

## 进一步探索

### 一般的词法分析器

![Alt text](../img/lexical_analysis.png)

```c++
TOKEN-TYPE              TOKEN-VALUE
-----------------------------------------------
T_IF                    if
T_WHILE                 while
T_ASSIGN                =
T_GREATTHAN             >
T_GREATEQUAL            >=
T_IDENTIFIER            name / numTickets / ...
T_INTEGERCONSTANT       100 / 1 / 12 / ....
T_STRINGCONSTANT        "This is a string" / "hello" / ...

typedef enum {
    T_IF, T_WHILE, T_ADD, T_INTCONSTANT, T_STRINGCONSTANT, T_IDENTIFIER, ...
} TokenType;

typedef struct _Token {
    TokenType type;
    union {
        char *stringval;
        int *intval;
        double *doubleval;
    } value;
} TokenRecord;
```

分词扫描的方法有**直接扫描法**和**正则表达式匹配扫描法**。

直接扫描法的思路非常简单，每轮扫描，根据第一个字符判断属于哪种类型的 token ，然后采取不同的策略扫描出一个完整的 token ，再接着进行下一轮扫描。例如 TinyC 中，若仅考虑一些简单的情况，按 token 的第一个字符，可以将所有类别的 token 分为以下 7 大类：

（1）A 型单字符运算符

包括：+, -, \*, /, %， 这种 token 只有一个字符，若本轮扫描的第一个字符为上述字符，则立即返回此字符所代表的 token ，然后移到下一个字符开始下一轮扫描。

（2）B 型单字符运算符和双字符运算符

B 型单字符运算符包括： < > = ! ，双字符运算符包括： <=, >=, ==, != 。 若本轮扫描的第一个字符为 B 型单字符运算符时，先查看下一个字符是否是 “=” ，如果是，则返回这两个字符代表的 token ，如果否，则返回这个字符代表的 token 。例如，如果扫描到 “>” ，则查看下一个字符是否是 “=” ，是则返回 T_GREATEEQUAL ，否则返回 T_GREATTHAN 。

（3）关键词和标识符

关键词和标识符都是以字母或下划线开始、且只有字母、下划线或数字组成。若本轮扫描的第一个字符为字母或下划线时，则一直向后扫描，直到遇到第一个既不是字母、也不是下划线或数字的字符，此时一个完整的词就被扫描出来了，然后，查看这个词是不是为关键字，如果是，则返回关键字代表的 token ，如果不是，则返回 T_IDENTIFIER 以及这个词的字面值。

（4）整数常量

整数常量以数字开始，若本轮扫描的第一个字符为数字，则一直向后扫描，直到遇到第一个非数字字符，然后返回 T_INTEGERCONSTANT 和这个数字。

（5）字符串常量

字符串常量以双引号开始和结束，若本轮扫描的第一个字符为双引号，则一直向后扫描，直到遇到第一个双引号，然后返回 T_STRINGCONSTANT 和这个字符串。

（6）空格

若本轮扫描的第一个字符为空格，则跳过此字符。

（7）注释

注释仅考虑以 # 开始的情况，若本轮扫描的第一个字符为 #，则直接跳过此行字符流。

```python
# 直接扫描法的一个python实现
def scan(s):
    n, i = len(s), 0
    while i < n:
        ch, i = s[i], i + 1

        if isWhiteSpace(ch):
            continue

        if ch == "#":
            return

        if ch in single_char_operators_typeA:
            yield Token(ch)
        elif ch in single_char_operators_typeB:
            if i < n and s[i] == "=":
                yield Token(ch + "=")
            else:
                yield Token(ch)
        elif isLetter(ch) or ch == "_":
            begin = i - 1
            while i < n and (isLetter(s[i]) or isDigit(s[i]) or s[i] == "_"):
                i += 1
            word = s[begin:i]
            if word in reservedWords:
                yield Token(word)
            else:
                yield Token("T_identifier", word)
        elif isDigit(ch):
            begin = i - 1
            aDot = False
            while i < n:
                if s[i] == ".":
                    if aDot:
                        raise Exception("Too many dot in a number!\n\tline:"+line)
                    aDot = True
                elif not isDigit(s[i]):
                    break
                i += 1
            yield Token("T_double" if aDot else "T_integer", s[begin:i])
        elif ord(ch) == 34: # 34 means '"'
            begin = i
            while i < n and ord(s[i]) != 34:
                i += 1
            if i == n:
                raise Exception("Non-terminated string quote!\n\tline:"+line)
            yield Token("T_string", chr(34) + s[begin:i] + chr(34))
            i += 1
        else:
            raise Exception("Unknown symbol!\n\tline:"+line+"\n\tchar:"+ch)
```

可以看出直接扫描法思路简单，代码量非常少，scan.py 不过 100 代码。但缺点是速度慢，对标识符类型的 token 需要进行至少 2 次扫描，且需进行字符串查找和比较。而且不容易扩展，只适用于语法简单的语言。目前一般的编译器都是采用基于正则表达式匹配的分词扫描法，以下介绍此方法。

正则表达式则是通过有限状态自动机 FA 实现的。

## 总结

目前只实现了直接扫描法，速度有点慢。还有一点要做的是，词法分析器最终要 output 一个 token stream 吧，目前只是 print 了一下。
