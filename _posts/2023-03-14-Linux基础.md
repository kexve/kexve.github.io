---
layout: post
title: Linux 基础
categories: [Linux, 面试]
---

## 说⼀下 fork， wait， exec 函数

⽗进程产⽣⼦进程使⽤ fork 拷⻉出来⼀个⽗进程的副本，此时只拷⻉了⽗进程的⻚表，两个进程都读同⼀块内
存。

当有进程写的时候使⽤写实拷⻉机制分配内存， exec 函数可以加载⼀个 elf ⽂件去替换⽗进程，从此⽗进程和⼦进
程就可以运⾏不同的程序了。

fork 从⽗进程返回⼦进程的 pid，从⼦进程返回 0，调⽤了 wait 的⽗进程将会发⽣阻塞，直到有⼦进程状态改变，
执⾏成功返回 0，错误返回 -1。

exec 执⾏成功则⼦进程从新的程序开始运⾏，⽆返回值，执⾏失败返回 -1。

## select、poll、epoll 之间的区别

### epoll V.S select

select 的调用复杂度 O(n)。如一个保姆照看一群孩子，如果把孩子是否需要尿尿比作网络 I/O 事件，select 就像保姆挨个询问每个孩子：你要尿尿吗？若孩子回答是，保姆则把孩子拎出来放到另外一个地方。当所有孩子询问完之后，保姆领着这些要尿尿的孩子去上厕所（处理网络 I/O 事件）

epoll 机制下，保姆无需挨个询问孩子是否要尿尿，而是每个孩子若自己需要尿尿，主动站到事先约定好的地方，而保姆职责就是查看事先约定好的地方是否有孩子。若有小孩，则领着孩子去上厕所（网络事件处理）。因此，epoll 的这种机制，能够高效的处理成千上万的并发连接，而且性能不会随着连接数增加而下降。

![20230321134836](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230321134836.png)

### 总结

select，poll，epoll 都是 I/O 多路复用机制，即能监视多个 fd，一旦某 fd 就绪（读或写就绪），能够通知程序进行相应读写操作。 但 select，poll，epoll 本质都是同步 I/O，因为他们都需在读写事件就绪后，自己负责进行读写，即该读写过程是阻塞的，而异步 I/O 则无需自己负责进行读写，异步 I/O 实现会负责把数据从内核拷贝到用户空间。

select，poll 需自己主动不断轮询所有 fd 集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而 epoll 其实也需调用 epoll_wait 不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但它是设备就绪时，调用回调函数，把就绪 fd 放入就绪链表，并唤醒在 epoll_wait 中进入睡眠的进程。**虽然都要睡眠和交替，但 select 和 poll 在“醒着”时要遍历整个 fd 集合，而 epoll 在“醒着”的时候只需判断就绪链表是否为空，节省大量 CPU 时间，这就是回调机制带来的性能提升。**

select，poll 每次调用都要把 fd 集合从用户态往内核态拷贝一次，且要把 current 往设备等待队列中挂一次，而 epoll 只要一次拷贝，且把 current 往等待队列上挂也只挂一次（在 epoll_wait 开始，注意这里的等待队列并不是设备等待队列，只是一个 epoll 内部定义的等待队列）。这也能节省不少开销。

## 缺页中断

在请求分页系统中，可以通过查询页表中的状态位来确定所要访
问的页面是否存在于内存中。每当所要访问的页面不在内存是，会产生一次
缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页
，将其调入内存。

缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：

```
1、保护CPU现场
2、分析中断原因
3、转入缺页中断处理程序进行处理
4、恢复CPU现场，继续执行
```

但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：

```
1、在指令执行期间产生和处理缺页中断信号
2、一条指令在执行期间，可能产生多次缺页中断
3、缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令。
```

## 讲一下协程

