---
layout: post
title: Linux 基础
categories: [Linux, 面试]
---

## 说⼀下 fork， wait， exec 函数

⽗进程产⽣⼦进程使⽤ fork 拷⻉出来⼀个⽗进程的副本，此时只拷⻉了⽗进程的⻚表，两个进程都读同⼀块内
存。

当有进程写的时候使⽤写实拷⻉机制分配内存， exec 函数可以加载⼀个 elf ⽂件去替换⽗进程，从此⽗进程和⼦进
程就可以运⾏不同的程序了。

fork 从⽗进程返回⼦进程的 pid，从⼦进程返回 0，调⽤了 wait 的⽗进程将会发⽣阻塞，直到有⼦进程状态改变，
执⾏成功返回 0，错误返回 -1。

exec 执⾏成功则⼦进程从新的程序开始运⾏，⽆返回值，执⾏失败返回 -1。

## select、poll、epoll 之间的区别

### epoll V.S select

select 的调用复杂度 O(n)。如一个保姆照看一群孩子，如果把孩子是否需要尿尿比作网络 I/O 事件，select 就像保姆挨个询问每个孩子：你要尿尿吗？若孩子回答是，保姆则把孩子拎出来放到另外一个地方。当所有孩子询问完之后，保姆领着这些要尿尿的孩子去上厕所（处理网络 I/O 事件）

epoll 机制下，保姆无需挨个询问孩子是否要尿尿，而是每个孩子若自己需要尿尿，主动站到事先约定好的地方，而保姆职责就是查看事先约定好的地方是否有孩子。若有小孩，则领着孩子去上厕所（网络事件处理）。因此，epoll 的这种机制，能够高效的处理成千上万的并发连接，而且性能不会随着连接数增加而下降。

![20230321134836](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230321134836.png)

### 总结

select，poll，epoll 都是 I/O 多路复用机制，即能监视多个 fd，一旦某 fd 就绪（读或写就绪），能够通知程序进行相应读写操作。 但 select，poll，epoll 本质都是同步 I/O，因为他们都需在读写事件就绪后，自己负责进行读写，即该读写过程是阻塞的，而异步 I/O 则无需自己负责进行读写，异步 I/O 实现会负责把数据从内核拷贝到用户空间。

select，poll 需自己主动不断轮询所有 fd 集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而 epoll 其实也需调用 epoll_wait 不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但它是设备就绪时，调用回调函数，把就绪 fd 放入就绪链表，并唤醒在 epoll_wait 中进入睡眠的进程。**虽然都要睡眠和交替，但 select 和 poll 在“醒着”时要遍历整个 fd 集合，而 epoll 在“醒着”的时候只需判断就绪链表是否为空，节省大量 CPU 时间，这就是回调机制带来的性能提升。**

select，poll 每次调用都要把 fd 集合从用户态往内核态拷贝一次，且要把 current 往设备等待队列中挂一次，而 epoll 只要一次拷贝，且把 current 往等待队列上挂也只挂一次（在 epoll_wait 开始，注意这里的等待队列并不是设备等待队列，只是一个 epoll 内部定义的等待队列）。这也能节省不少开销。

## 缺页中断

在请求分页系统中，可以通过查询页表中的状态位来确定所要访
问的页面是否存在于内存中。每当所要访问的页面不在内存是，会产生一次
缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页
，将其调入内存。

缺页本身是一种中断，与一般的中断一样，需要经过 4 个处理步骤：

```
1、保护CPU现场
2、分析中断原因
3、转入缺页中断处理程序进行处理
4、恢复CPU现场，继续执行
```

但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：

```
1、在指令执行期间产生和处理缺页中断信号
2、一条指令在执行期间，可能产生多次缺页中断
3、缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令。
```

## 讲一下进程

我们都知道计算机的核心是 CPU，它承担了所有的计算任务；而操作系统是计算机的管理者，它负责任务的调度、资源的分配和管理，统领整个计算机硬件；应用程序则是具有某种功能的程序，程序是运行于操作系统之上的。

**进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程**，是操作系统进行资源分配和调度的一个独立单位，**是应用程序运行的载体**。进程是一种抽象的概念，从来没有统一的标准定义。

进程一般由**程序、数据集合和进程控制块**三部分组成。

1. 程序用于描述进程要完成的功能，是控制进程执行的指令集；
2. 数据集合是程序在执行时所需要的数据和工作区；
3. 程序控制块(Program Control Block，简称 PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。

进程具有的特征：

1. 动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；
2. 并发性：任何进程都可以同其他进程一起并发执行；
3. 独立性：进程是系统进行资源分配和调度的一个独立单位；
4. 结构性：进程由程序、数据和进程控制块三部分组成。

## 线程

在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。

后来，随着计算机的发展，对 CPU 的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程。

**线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位**。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程 ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。

（读到这里可能有的读者迷糊，感觉这和 Java 的内存空间模型不太一样，但如果你深入的读过深入理解 Java 虚拟机这本书的话你就会恍然大悟）

![20230322094829](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230322094829.png)

如上图，在任务管理器的进程一栏里，有道词典和有道云笔记就是进程，而在进程下又有着多个执行不同任务的线程。
