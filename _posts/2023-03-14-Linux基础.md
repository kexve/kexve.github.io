---
layout: post
title: Linux 基础
categories: [Linux, 面试]
---

## 说⼀下 fork， wait， exec 函数

⽗进程产⽣⼦进程使⽤ fork 拷⻉出来⼀个⽗进程的副本，此时只拷⻉了⽗进程的⻚表，两个进程都读同⼀块内
存。

当有进程写的时候使⽤写实拷⻉机制分配内存， exec 函数可以加载⼀个 elf ⽂件去替换⽗进程，从此⽗进程和⼦进
程就可以运⾏不同的程序了。

fork 从⽗进程返回⼦进程的 pid，从⼦进程返回 0，调⽤了 wait 的⽗进程将会发⽣阻塞，直到有⼦进程状态改变，
执⾏成功返回 0，错误返回 -1。

exec 执⾏成功则⼦进程从新的程序开始运⾏，⽆返回值，执⾏失败返回 -1。

## select、poll、epoll 之间的区别

### epoll V.S select

select 的调用复杂度 O(n)。如一个保姆照看一群孩子，如果把孩子是否需要尿尿比作网络 I/O 事件，select 就像保姆挨个询问每个孩子：你要尿尿吗？若孩子回答是，保姆则把孩子拎出来放到另外一个地方。当所有孩子询问完之后，保姆领着这些要尿尿的孩子去上厕所（处理网络 I/O 事件）

epoll 机制下，保姆无需挨个询问孩子是否要尿尿，而是每个孩子若自己需要尿尿，主动站到事先约定好的地方，而保姆职责就是查看事先约定好的地方是否有孩子。若有小孩，则领着孩子去上厕所（网络事件处理）。因此，epoll 的这种机制，能够高效的处理成千上万的并发连接，而且性能不会随着连接数增加而下降。

![20230321134836](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230321134836.png)

### 总结

select，poll，epoll 都是 I/O 多路复用机制，即能监视多个 fd，一旦某 fd 就绪（读或写就绪），能够通知程序进行相应读写操作。 但 select，poll，epoll 本质都是同步 I/O，因为他们都需在读写事件就绪后，自己负责进行读写，即该读写过程是阻塞的，而异步 I/O 则无需自己负责进行读写，异步 I/O 实现会负责把数据从内核拷贝到用户空间。

select，poll 需自己主动不断轮询所有 fd 集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而 epoll 其实也需调用 epoll_wait 不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但它是设备就绪时，调用回调函数，把就绪 fd 放入就绪链表，并唤醒在 epoll_wait 中进入睡眠的进程。**虽然都要睡眠和交替，但 select 和 poll 在“醒着”时要遍历整个 fd 集合，而 epoll 在“醒着”的时候只需判断就绪链表是否为空，节省大量 CPU 时间，这就是回调机制带来的性能提升。**

select，poll 每次调用都要把 fd 集合从用户态往内核态拷贝一次，且要把 current 往设备等待队列中挂一次，而 epoll 只要一次拷贝，且把 current 往等待队列上挂也只挂一次（在 epoll_wait 开始，注意这里的等待队列并不是设备等待队列，只是一个 epoll 内部定义的等待队列）。这也能节省不少开销。

## 缺页中断

在请求分页系统中，可以通过查询页表中的状态位来确定所要访
问的页面是否存在于内存中。每当所要访问的页面不在内存是，会产生一次
缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页
，将其调入内存。

缺页本身是一种中断，与一般的中断一样，需要经过 4 个处理步骤：

```
1、保护CPU现场
2、分析中断原因
3、转入缺页中断处理程序进行处理
4、恢复CPU现场，继续执行
```

但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：

```
1、在指令执行期间产生和处理缺页中断信号
2、一条指令在执行期间，可能产生多次缺页中断
3、缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令。
```

## 讲一下进程

我们都知道计算机的核心是 CPU，它承担了所有的计算任务；而操作系统是计算机的管理者，它负责任务的调度、资源的分配和管理，统领整个计算机硬件；应用程序则是具有某种功能的程序，程序是运行于操作系统之上的。

**进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程**，是操作系统进行资源分配和调度的一个独立单位，**是应用程序运行的载体**。进程是一种抽象的概念，从来没有统一的标准定义。

进程一般由**程序、数据集合和进程控制块**三部分组成。

1. 程序用于描述进程要完成的功能，是控制进程执行的指令集；
2. 数据集合是程序在执行时所需要的数据和工作区；
3. 程序控制块(Program Control Block，简称 PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。

进程具有的特征：

1. 动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；
2. 并发性：任何进程都可以同其他进程一起并发执行；
3. 独立性：进程是系统进行资源分配和调度的一个独立单位；
4. 结构性：进程由程序、数据和进程控制块三部分组成。

## 线程

在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。

后来，随着计算机的发展，对 CPU 的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程。

**线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位**。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程 ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。

（读到这里可能有的读者迷糊，感觉这和 Java 的内存空间模型不太一样，但如果你深入的读过深入理解 Java 虚拟机这本书的话你就会恍然大悟）

![20230322094829](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230322094829.png)

如上图，在任务管理器的进程一栏里，有道词典和有道云笔记就是进程，而在进程下又有着多个执行不同任务的线程。

## 协程

协程（Coroutine）是一种轻量级的线程，可以在单个线程中实现并发执行。它是一种非抢占式的多任务处理方式，也就是说，在协程中，任务的执行顺序由程序员自己控制，不需要操作系统进行上下文切换。因此，协程可以有效地避免线程上下文切换所带来的开销和延迟，从而提高程序的性能和响应速度。

协程和线程不同的是，线程是由操作系统进行调度的，而协程是由程序本身进行调度的。协程通常由一个主协程和多个子协程组成，主协程负责管理和调度子协程的执行。

协程可以在同一线程内并发执行，也可以在多个线程之间切换执行。在 Python 中，协程通过使用生成器函数和 async/await 语法来实现。通过使用协程，可以方便地编写高效、可扩展的并发程序。

## 进程的状态与转换

### 三态模型

1. 运行态(running): 占有处理器正在运行
2. 就绪态(ready): 具备运行条件，等待系统分配处理器以便运行
3. 等待态(blocked): 不具备运行条件，正在等待某个事件的完成

![20230327135858](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230327135858.png)

引起进程状态转换的具体原因如下：

1. 运行态 → 等待态：等待使用资源；如等待外设传输；等待人工干预。
2. 等待态 → 就绪态：资源得到满足；如外设传输结束；人工干预完成。
3. 运行态 → 就绪态：运行时间片到；出现有更高优先权进程。
4. 就绪态 → 运行态：CPU 空闲时选择一个就绪进程。

### 五态模型

在一个实际的系统里进程的状态及其转换比上节叙述的会复杂一些，例如引入专门的新建态（new）和终止态（exit ）

![20230327140140](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230327140140.png)

新建态对应于进程刚刚被创建的状态。创建一个进程要通过两个步骤，

1. 为一个新进程创建必要的管理信息，
2. 让该进程进入就绪态。此时进程将处于新建态，它并没有被提交执行，而是在等待操作系统完成创建进程的必 要操作。需要注意的是，操作系统有时将根据系统性能或主存容量的限制推迟新建态进程的提交

类似地，进程的终止也要通过两个步骤，首先,是等待操作系统进行善后，然后,退出主存。当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结，它将进入终止态。进入终止态的进程以后不再执行，但依然临时保留在操作系统中等待善后。一旦其他进程完成了对终止态进程的信息抽取之后，操作系统将删除该进程。

引起进程状态转换的具体原因如下：

1. NULL—→ 新建态：执行一个程序，创建一个子进程。
2. 新建态—→ 就绪态：当操作系统完成了进程创建的必要操作，并且当前系统的性能和虚拟内存的容量均允许。
3. 运行态—→ 终止态：当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结。
4. 终止态—→NULL：完成善后操作。
5. 就绪态—→ 终止态：未在状态转换图中显示，但某些操作系统允许父进程终结子进程。
6. 等待态—→ 终止态：未在状态转换图中显示，但某些操作系统允许父进程终结子进程。

### 七态模型

**进程的挂起**

到目前为止，我们或多或少**总是假设所有的进程都在内存中**。**_进程挂起并不一定意味着进程在二级存储器中，而是指进程的执行被暂停，其内存空间可能会被交换出到二级存储器中，也可能仍然留在内存中_**。事实上，可能出现这样一些情况，例如由于进程的不断创建，系统的资源已经不能满足进程运行的要求，这个时候就必须把某些进程挂起（suspend），对换到磁盘镜像区中，暂时不参与进程调度，起到平滑系统操作负荷的目的。

引起进程挂起的原因是多样的，主要有：

1. 系统中的进程均处于等待状态，处理器空闲，此时需要把一些阻塞进程对换出去，以腾出足够的内存装入就绪进程运行。
2. 进程竞争资源，导致系统资源不足，负荷过重，此时需要挂起部分进程以调整系统负荷 ,保证系统的实时性或让系统正常运行。
3. 把一些定期执行的进程（如审计程序、监控程序、记账程序）对换出去，以减轻系统负荷。
4. 用户要求挂起自己的进程，以便根据中间执行情况和中间结果进行某些调试、检查和改正。
5. 父进程要求挂起自己的后代进程，以进行某些检查和改正。
6. 操作系统需要挂起某些进程，检查运行中资源使用情况，以改善系统性能;或当系统出现故障或某些功能受到破坏时，需要挂起某些进程以排除故障。

![20230327141558](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230327141558.png)

在此类系统中，进程增加了两个新状态：

1. 挂起就绪态（ready,suspend），挂起就绪态表明了进程具备运行条件但目前在二级存储器中，只有当它被对换到主存才能被调度执行
2. 挂起等待态（blocked,suspend）挂起等待态则表明了进程正在等待某一个事件且在二级存储器中。

一个挂起进程具有如下特征：

1. 该进程不能立即被执行。
2. 挂起进程可能会等待一个事件，但所等待的事件是独立于挂起条件的，事件结束并不能导致进程具备执行条件。
3. 进程进入挂起状态是由于操作系统、父进程或进程本身阻止它的运行。
4. 结束进程挂起状态的命令只能通过操作系统或父进程发出。

### 进程挂起和进程等待

进程挂起和进程等待是操作系统中两个不同的概念。

**进程挂起是指将进程从可运行状态转变为不可运行状态**，同时将进程的所有上下文信息保存在内存中，**并将 CPU 的控制权交给另一个进程**。当一个进程被挂起时，它不能够执行任何代码，直到它被唤醒。进程挂起通常是由于等待某些事件的发生而引起的，例如等待输入/输出操作完成、等待某个信号量被释放等。

进程等待是指一个进程正在等待另一个进程完成某个特定的操作，例如等待另一个进程发送数据、等待另一个进程释放共享资源等。**当一个进程在等待时，它仍然处于可运行状态，可以执行其他操作，直到等待的操作完成。**

因此，进程挂起和进程等待是不同的概念，但它们之间存在联系。在某些情况下，一个进程可能需要被挂起以等待另一个进程完成某个操作。例如，一个进程可能需要等待某个文件的输入/输出操作完成，这时候可以将该进程挂起，等待文件操作完成后再唤醒它。

### Linux 操作系统的进程

```c
/*
* The task state array is a strange "bitmap" of
* reasons to sleep. Thus "running" is zero, and
* you can test for combinations of others with
* simple bit tests.
*/
static const char * const task_state_array[] = {
    "R (running)", /* 0 */
    "S (sleeping)", /* 1 */
    "D (disk sleep)", /* 2 */
    "T (stopped)", /* 4 */
    "t (tracing stop)", /* 8 */
    "X (dead)", /* 16 */
    "Z (zombie)", /* 32 */
};
```

从 Linux 源码中可以看出，Linux 下有 7 中进程状态：

1. R 运行状态（Running）：处于运行状态的进程并不带表一定就正在被 CPU 调度运行，**它包括了正在被 CPU 运行的进程和可以被 CPU 调度运行的程序，也就是说改状态包含了三状态模型中的就绪态和运行态**。
2. S 睡眠状态（Sleeping）：处于改状态的进程表示该进程正在等待某时间的完成，通常也称为可中断睡眠状态，该状态属于三状态模型中的**阻塞态**。
3. D 磁盘休眠状态（disk sleep）：该状态也叫做不可中断睡眠状态，处于该状态的进程通常都在等待 I/O 操作的结束，该状态也属于三状态模型中的**阻塞态**。
4. T 停止状态（stopped）：我们可以通过向进程发送 SIGSTOP 信号让目标进程处于停止状态，通过向处于停止状态的进程发送 SIGCON 信号让目标进程继续运行，该状态也属于三状态模型中的**阻塞态**。
5. t 追踪停止状态（tracing stop）：
6. X 死亡状态（dead）：该状态只是一个返回状态，不会在任务列表中见到，该状态属于**退出状态**。
7. Z 僵尸状态（zombie）：当一个进程退出，但它的父进程并没有去收回该进程的信息时，该进程所处的状态叫做僵尸状态，该状态属于**退出状态**。

![20230327142657](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230327142657.png)

创建一个新进程，操作系统会为该新进程创建一个空白 PCB（task_struct）,用来存储该进程的各项信息。
