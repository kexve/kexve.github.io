---
layout: post
title: Redis 数据库基础
categories: [数据库, 面试]
---

## 关系型和⾮关系型数据库的区别

### 关系型

关系型数据库是指采用了关系模型来组织数据的数据库。简单来说，关系模式就是二维表格模型。

主要代表：SQL Server，Oracle,Mysql,PostgreSQL。

#### 优点

（1）容易理解，二维表的结构非常贴近现实世界，二维表格，容易理解。

（2）使用方便，通用的 sql 语句使得操作关系型数据库非常方便。

（3）易于维护，数据库的 ACID 属性，大大降低了数据冗余和数据不一致的概率。

#### 瓶颈

（1）海量数据的读写效率。
对于网站的并发量高，往往达到每秒上万次的请求，对于传统关系型数据库来说，硬盘 I/o 是一个很大的挑战。

（2）高扩展性和可用性。
在基于 web 的结构中，数据库是最难以横向拓展的，当一个应用系统的用户量和访问量与日俱增的时候，数据库没有办法像 web Server 那样简单的通过添加更多的硬件和服务节点来拓展性能和负载能力。

### 从关系型到非关系型

关系型数据库的最大优点就是事务的一致性，这个特性，使得关系型数据库中可以适用于一切要求一致性比较高的系统中。比如：银行系统。

**但是在网页应用中，对这种一致性的要求不是那么的严格，允许有一定的时间间隔**，所以关系型数据库这个特点不是那么的重要了。相反，关系型数据库为了维护一致性所付出的巨大代价就是读写性能比较差。而像微博、facebook 这类应用，对于并发读写能力要求极高，关系型数据库已经无法应付。所以必须用一种新的数据结构存储来替代关系型数据库。所以非关系型数据库应用而生。

### 非关系型

NoSQL 非关系型数据库，主要指那些非关系型的、分布式的，且一般不保证 ACID 的数据存储系统，主要代表 MongoDB，Redis、CouchDB。

_NoSQL 提出了另一种理念，以键值来存储，且结构不稳定，每一个元组都可以有不一样的字段，这种就不会局限于固定的结构，可以减少一些时间和空间的开销_。使用这种方式，为了获取用户的不同信息，不需要像关系型数据库中，需要进行多表查询。仅仅需要根据 key 来取出对应的 value 值即可。

#### 分类

非关系数据库大部分是开源的，实现比较简单，大都是针对一些特性的应用需求出现的。根据结构化方法和应用场景的不同，分为以下几类。

（1）**面向高性能并发读写的 key-value 数据库**。主要特点是具有极高的并发读写性能，例如**Redis**、Tokyo Cabint 等。

（2）**面向海量数据访问的面向文档数据库**。特点是，可以在海量的数据库快速的查询数据。例如**MongoDB** 以及 CouchDB.

（3）面向可拓展的分布式数据库。解决的主要问题是传统数据库的扩展性上的缺陷。

#### 缺点

但是由于Nosql约束少，所以也不能够像sql那样提供where字段属性的查询。因此适合存储较为简单的数据。有一些不能够持久化数据，所以需要和关系型数据库结合。

## Redis 是什么？简述它的优缺点？

Redis 本质上是一个 Key-Value（键值对，非关系型）类型的内存数据库，很像 Memcached，整个数据库加载在内存当中操作，定期通过异步操作把数据库中的数据 flush 到硬盘上进行保存。

因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value 数据库。

### 优缺点

优点：

1. **读写性能极高**， Redis 能读的速度是 110000 次/s，写的速度是 81000 次/s。

2. **支持数据持久化**，支持 AOF 和 RDB 两种持久化方式。

3. **支持事务**， Redis 的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来。

4. **数据结构丰富**，除了支持 string 类型的 value 外，还支持 hash、set、zset、list 等数据结构。

5. **支持主从复制**，主机会自动将数据同步到从机，可以进行读写分离。

6. **丰富的特性** – Redis 还支持 publish/subscribe， 通知， key 过期等特性。

7. Redis 是**单线程**的，避免线程切换开销及多线程的竞争问题。单线程是指网络请求使用一个线程来处理，Redis 运行是不止有一个线程，比如数据持久化的过程会另起线程。

缺点：

1. 数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在**较小数据量**的高性能操作和运算上。

2. 主机宕机，**宕机前有部分数据未能及时同步到从机，切换 IP 后还会引入数据不一致的问题**，降低了系统的可用性。

## Redis 为什么这么快？

1. 内存存储：Redis 是使用内存(in-memeroy)存储，没有磁盘 IO 上的开销。_数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O(1)_。

2. 单线程实现（ Redis 6.0 以前）：_Redis 使用单个线程处理请求，避免了多个线程之间线程切换和锁资源争用的开销_。注意：单线程是指的是在核心网络模型中，网络请求模块使用一个线程来处理，即一个线程处理所有网络请求。

3. 非阻塞 IO：_Redis 使用多路复用 IO 技术_，将 epoll 作为 I/O 多路复用技术的实现，_再加上 Redis 自身的事件处理模型将 epoll 中的连接、读写、关闭都转换为事件，不在网络 I/O 上浪费过多的时间_。

4. 优化的数据结构：Redis 每种数据类型底层都做了优化，目的就是为了追求更快的速度。

5. 使用底层模型不同：Redis 直接自己*构建了 VM (虚拟内存)机制*，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

6. Redis 的 VM(虚拟内存)机制就是暂时把不经常访问的数据(冷数据)从内存交换到磁盘中，从而腾出宝贵的内存空间用于其它需要访问的数据(热数据)。通过*VM 功能可以实现冷热数据分离，使热数据仍在内存中、冷数据保存到磁盘*。这样就可以避免因为内存不足而造成访问速度下降的问题。

7. Redis 提高数据库容量的办法有两种：_一种是可以将数据分割到多个 RedisServer 上；另一种是使用虚拟内存把那些不经常访问的数据交换到磁盘上_。需要特别注意的是**Redis 并没有使用 OS 提供的 Swap，而是自己实现**。

## Redis 为何选择单线程？

1. 避免过多的上下文切换开销。程序始终运行在进程中单个线程内，没有多线程切换的场景。

2. 避免同步机制的开销：如果 Redis 选择多线程模型，需要考虑数据同步的问题，则必然会引入某些同步机制，会导致在操作数据过程中带来更多的开销，增加程序复杂度的同时还会降低性能。

3. 实现简单，方便维护：如果 Redis 使用多线程模式，那么所有的底层数据结构的设计都必须考虑线程安全问题，那么 Redis 的实现将会变得更加复杂。

## Redis 应用场景有哪些？

1. 缓存热点数据，缓解数据库的压力。

2. 利用 Redis 原子性的自增操作，可以实现计数器的功能，比如统计用户点赞数、用户访问数等。

3. 简单的消息队列，可以使用 Redis 自身的发布/订阅模式或者 List 来实现简单的消息队列，实现异步操作。

4. 限速器，可用于限制某个用户访问某个接口的频率，比如秒杀场景用于防止用户快速点击带来不必要的压力。

5. 好友关系，利用集合的一些命令，比如交集、并集、差集等，实现共同好友、共同爱好之类的功能。

## Memcached 和 Redis 的区别？

1. Redis 只使用单核，而 Memcached 可以使用多核。
2. MemCached 数据结构单一，仅用来缓存数据，而 Redis 支持多种数据类型。
3. MemCached 不支持数据持久化，重启后数据会消失。Redis 支持数据持久化。
4. Redis 提供主从同步机制和 cluster 集群部署能力，能够提供高可用服务。Memcached 没有提供原生的集群模式，需要依靠客户端实现往集群中分片写入数据。
5. Redis 的速度比 Memcached 快很多。
6. Redis 使用单线程的多路 IO 复用模型，Memcached 使用多线程的非阻塞 IO 模型。

## Redis 数据类型有哪些？

### 基本数据类型：

1. String：最常用的一种数据类型，String 类型的值可以是字符串、数字或者二进制，但值最大不能超过 512MB。

2. Hash：Hash 是一个键值对集合。

3. Set：无序去重的集合。Set 提供了交集、并集等方法，对于实现共同好友、共同关注等功能特别方便。

4. List：有序可重复的集合，底层是依赖双向链表实现的。

5. SortedSet：有序 Set。内部维护了一个 score 的参数来实现。适用于排行榜和带权重的消息队列等场景。

### 特殊的数据类型：

1. Bitmap：位图，可以认为是一个以位为单位数组，数组中的每个单元只能存 0 或者 1，数组的下标在 Bitmap 中叫做偏移量。Bitmap 的长度与集合中元素个数无关，而是与基数的上限有关。

2. Hyperloglog。HyperLogLog 是用来做基数统计的算法，其优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。典型的使用场景是统计独立访客。

3. Geospatial ：主要用于存储地理位置信息，并对存储的信息进行操作，适用场景如定位、附近的人等。

## Redis 事务

事务的原理是将一个事务范围内的若干命令发送给 Redis，然后再让 Redis 依次执行这些命令。

事务的生命周期：

1. 使用 MULTI 开启一个事务；
2. 在开启事务的时候，每次操作的命令将会被插入到一个队列中，同时这个命令并不会被真正执行；
3. EXEC 命令进行提交事务。

![20230315110758](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230315110758.png)

一个事务范围内某个命令出错不会影响其他命令的执行，不保证原子性：

```bash
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set a 1
QUEUED
127.0.0.1:6379> set b 1 2
QUEUED
127.0.0.1:6379> set c 3
QUEUED
127.0.0.1:6379> exec
1) OK
2) (error) ERR syntax error
3) OK
```

### WATCH 命令

WATCH 命令可以监控一个或多个键，一旦其中有一个键被修改，之后的事务就不会执行（类似于乐观锁）。执行 EXEC 命令之后，就会自动取消监控。

```
127.0.0.1:6379> watch name
OK
127.0.0.1:6379> set name 1
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set name 2
QUEUED
127.0.0.1:6379> set gender 1
QUEUED
127.0.0.1:6379> exec
(nil)
127.0.0.1:6379> get gender
(nil)
```

比如上面的代码中：

watch name 开启了对 name 这个 key 的监控

修改 name 的值

开启事务 a

在事务 a 中设置了 name 和 gender 的值

使用 EXEC 命令进提交事务

使用命令 get gender 发现不存在，即事务 a 没有执行

使用 UNWATCH 可以取消 WATCH 命令对 key 的监控，所有监控锁将会被取消。

## 持久化机制

持久化就是把内存的数据写到磁盘中，防止服务宕机导致内存数据丢失。

Redis 支持两种方式的持久化，一种是 RDB 的方式，一种是 AOF 的方式。前者会根据指定的规则定时将内存中的数据存储在硬盘上，而后者在每次执行完命令后将命令记录下来。一般将两者结合使用。

### RDB 方式

RDB 是 Redis 默认的持久化方案。_RDB 持久化时会将内存中的数据写入到磁盘中，在指定目录下生成一个 dump.rdb 文件_。Redis 重启会加载 dump.rdb 文件恢复数据。

#### bgsave 是主流的触发 RDB 持久化的方式，执行过程如下：

1. 执行 BGSAVE 命令
2. Redis 父进程判断当前是否存在正在执行的子进程，如果存在，BGSAVE 命令直接返回。
3. 父进程执行 fork 操作创建子进程，fork 操作过程中父进程会阻塞。
4. 父进程 fork 完成后，父进程继续接收并处理客户端的请求，而子进程开始将内存中的数据写进硬盘的临时文件；
5. 当子进程写完所有数据后会用该临时文件替换旧的 RDB 文件。

Redis 启动时会读取 RDB 快照文件，将数据从硬盘载入内存。通过 RDB 方式的持久化，一旦 Redis 异常退出，就会丢失最近一次持久化以后更改的数据。

#### 触发 RDB 持久化的方式：

1. 手动触发：用户执行 SAVE 或 BGSAVE 命令。SAVE 命令执行快照的过程会阻塞所有客户端的请求，应避免在生产环境使用此命令。BGSAVE 命令可以在后台异步进行快照操作，快照的同时服务器还可以继续响应客户端的请求，因此需要手动执行快照时推荐使用 BGSAVE 命令。

2. 被动触发：
   根据配置规则进行自动快照，如 SAVE 100 10，100 秒内至少有 10 个键被修改则进行快照。
   如果从节点执行全量复制操作，主节点会自动执行 BGSAVE 生成 RDB 文件并发送给从节点。
   默认情况下执行 shutdown 命令时，如果没有开启 AOF 持久化功能则自动执行·BGSAVE·。

#### 优缺点

优点：

Redis **加载 RDB 恢复数据远远快于 AOF 的方式**。

使用**单独子进程来进行持久化**，主进程不会进行任何 IO 操作，保证了 Redis 的高性能。

缺点：

RDB 方式数据无法做到实时持久化。因为 BGSAVE 每次运行都要执行 fork 操作创建子进程，属于重量级操作，频繁执行成本比较高。

RDB 文件使用特定二进制格式保存，Redis 版本升级过程中有多个格式的 RDB 版本，存在老版本 Redis 无法兼容新版 RDB 格式的问题。

### AOF 方式

AOF（append only file）持久化：**以独立日志的方式记录每次写命令**，Redis 重启时会重新执行 AOF 文件中的命令达到恢复数据的目的。AOF 的主要作用是**解决了数据持久化的实时性，AOF 是 Redis 持久化的主流方式**。

默认情况下 Redis 没有开启 AOF 方式的持久化，可以通过 **appendonly** 参数启用：appendonly yes。开启 AOF 方式持久化后每执行一条写命令，Redis 就会将该命令写进 aof_buf 缓冲区，AOF 缓冲区根据对应的策略向硬盘做同步操作。

默认情况下系统每 30 秒会执行一次同步操作。为了防止缓冲区数据丢失，可以在 Redis 写入 AOF 文件后主动要求系统将缓冲区数据同步到硬盘上。可以通过 appendfsync 参数设置同步的时机。

```
appendfsync always //每次写入aof文件都会执行同步，最安全最慢，不建议配置
appendfsync everysec  //既保证性能也保证安全，建议配置
appendfsync no //由操作系统决定何时进行同步操作
```

### 接下来看一下 AOF 持久化执行流程：

1. 所有的写入命令会追加到 AOP 缓冲区中。
2. AOF 缓冲区根据对应的策略向硬盘同步。
3. 随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩文件体积的目的。AOF 文件重写是把 Redis 进程内的数据转化为写命令同步到新 AOF 文件的过程。
4. 当 Redis 服务器重启时，可以加载 AOF 文件进行数据恢复。

优点：

AOF 可以更好的保护数据不丢失，可以配置 AOF 每秒执行一次 fsync 操作，如果 Redis 进程挂掉，最多丢失 1 秒的数据。

AOF 以 append-only 的模式写入，所以没有磁盘寻址的开销，写入性能非常高。

缺点：

对于同一份文件 AOF 文件比 RDB 数据快照要大。

数据恢复比较慢。

## 主从复制

Redis 的复制功能是支持多个数据库之间的数据同步。主数据库可以进行读写操作，当主数据库的数据发生变化时会自动将数据同步到从数据库。**从数据库一般是只读的，它会接收主数据库同步过来的数据**。_一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库_。

```sh
redis-server //启动Redis实例作为主数据库
redis-server --port 6380 --slaveof  127.0.0.1 6379  //启动另一个实例作为从数据库
slaveof 127.0.0.1 6379
SLAVEOF NO ONE //停止接收其他数据库的同步并转化为主数据库。
```

### 主从复制的原理？

1. 当启动一个从节点时，它会发送一个 PSYNC 命令给主节点；
2. 如果是从节点初次连接到主节点，那么会**触发一次全量复制**。此时主节点会启动一个后台线程，开始**生成一份 RDB 快照文件**；
3. 同时还会将从客户端 client 新收到的所有写命令缓存在内存中。RDB 文件生成完毕后， 主节点会将 RDB 文件发送给从节点，从节点会先将 RDB 文件写入本地磁盘，然后再从本地磁盘加载到内存中；
4. 接着主节点会将内存中缓存的写命令发送到从节点，从节点同步这些数据；
5. 如果从节点跟主节点之间网络出现故障，连接断开了，会自动重连，连接之后主节点仅会将部分缺失的数据同步给从节点。

## 哨兵 Sentinel

主从复制存在不能自动故障转移、达不到高可用的问题。**哨兵模式解决了这些问题。通过哨兵机制可以自动切换主从节点。**

客户端连接 Redis 的时候，先连接哨兵，_哨兵会告诉客户端 Redis 主节点的地址_，然后客户端连接上 Redis 并进行后续的操作。_当主节点宕机的时候，哨兵监测到主节点宕机，会重新推选出某个表现良好的从节点成为新的主节点_，然后通过发布订阅模式通知其他的从服务器，让它们切换主机。

![20230315140729](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230315140729.png)

### 工作原理

每个 Sentinel 以每秒钟一次的频率向它所知道的 Master，Slave 以及其他 Sentinel 实例发送一个 PING 命令。

如果一个实例距离最后一次有效回复 PING 命令的时间超过指定值， 则这个实例会被 Sentine 标记为主观下线。

如果一个 Master 被标记为主观下线，则正在监视这个 Master 的所有 Sentinel 要以每秒一次的频率确认 Master 是否真正进入主观下线状态。

当有足够数量的 Sentinel（大于等于配置文件指定值）在指定的时间范围内确认 Master 的确进入了主观下线状态， 则 Master 会被标记为客观下线 。若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被解除。 若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。

哨兵节点会选举出哨兵 leader，负责故障转移的工作。

哨兵 leader 会推选出某个表现良好的从节点成为新的主节点，然后通知其他从节点更新主节点信息。

## Redis cluster 集群

Redis 集群是 Redis 提供的分布式数据库方案，集群通过分片( sharding )来实现数据共享，并提供复制和故障转移。

哨兵模式解决了主从复制不能自动故障转移、达不到高可用的问题，但还是**存在主节点的写能力、容量受限于单机配置的问题**。而 **cluster 模式实现了 Redis 的分布式存储**，每个节点存储不同的内容，解决主节点的写能力、容量受限于单机配置的问题。

Redis cluster 集群节点最小配置 6 个节点以上（3 主 3 从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。

Redis cluster 采用**虚拟槽分区**，所有的键根据**哈希函数**映射到 0 ～ 16383 个整数槽内，_每个节点负责维护一部分槽以及槽所映射的键值数据。_

优点：

1. 无中心架构，支持动态扩容；
2. 数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布；
3. 高可用性。部分节点不可用时，集群仍可用。集群模式能够实现自动故障转移（failover），节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色转换。

缺点：

1. **不支持批量操作**（pipeline）。
2. **数据通过异步复制，不保证数据的强一致性**。
3. 事务操作支持有限，只支持多 key 在同一节点上的事务操作，当多个 key 分布于不同的节点上时无法使用事务功能。
4. key 作为数据分区的最小粒度，不能将一个很大的键值对象如 hash、list 等映射到不同的节点。
5. 不支持多数据库空间，单机下的 Redis 可以支持到 16 个数据库，集群模式下只能使用 1 个数据库空间。

## 过期键的删除策略？

1. 被动删除。在访问 key 时，如果发现 key 已经过期，那么会将 key 删除。

2. 主动删除。定时清理 key，每次清理会依次遍历所有 DB，从 db 随机取出 20 个 key，如果过期就删除，如果其中有 5 个 key 过期，那么就继续对这个 db 进行清理，否则开始清理下一个 db。

3. 内存不够时清理。Redis 有最大内存的限制，通过 maxmemory 参数可以设置最大内存，当使用的内存超过了设置的最大内存，就要进行内存释放， 在进行内存释放的时候，会按照配置的淘汰策略清理内存。

## 内存淘汰策略有哪些？

当 Redis 的内存超过最大允许的内存之后，Redis 会触发内存淘汰策略，删除一些不常用的数据，以保证 Redis 服务器正常运行。

Redisv4.0 前提供 6 种数据淘汰策略：

1. volatile-lru：LRU（Least Recently Used），最近使用。利用 LRU 算法移除设置了过期时间的 key
2. allkeys-lru：当内存不足以容纳新写入数据时，从数据集中移除最近最少使用的 key
3. volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰
4. volatile-random：从已设置过期时间的数据集中任意选择数据淘汰
5. allkeys-random：从数据集中任意选择数据淘汰
6. no-eviction：禁止删除数据，当内存不足以容纳新写入数据时，新写入操作会报错

Redisv4.0 后增加以下两种：

1. volatile-lfu：LFU，Least Frequently Used，最少使用，从已设置过期时间的数据集中挑选最不经常使用的数据淘汰。
2. allkeys-lfu：当内存不足以容纳新写入数据时，从数据集中移除最不经常使用的 key。
3. 内存淘汰策略可以通过配置文件来修改，相应的配置项是 maxmemory-policy，默认配置是 noeviction。

## 如何保证缓存与数据库双写时的数据一致性？

1. 先删除缓存再更新数据库

   进行更新操作时，先删除缓存，然后更新数据库，后续的请求再次读取时，会从数据库读取后再将新数据更新到缓存。

   存在的问题：删除缓存数据之后，更新数据库完成之前，这个时间段内如果有新的读请求过来，就会从数据库读取旧数据重新写到缓存中，再次造成不一致，并且后续读的都是旧数据。

2. 先更新数据库再删除缓存

   进行更新操作时，先更新 MySQL，成功之后，删除缓存，后续读取请求时再将新数据回写缓存。

   存在的问题：更新 MySQL 和删除缓存这段时间内，请求读取的还是缓存的旧数据，不过等数据库更新完成，就会恢复一致，影响相对比较小。

3. 异步更新缓存

   数据库的更新操作完成后不直接操作缓存，而是把这个操作命令封装成消息扔到消息队列中，然后由 Redis 自己去消费更新数据，消息队列可以保证数据操作顺序一致性，确保缓存系统的数据正常。

## 缓存穿透

缓存穿透是指查询一个**不存在的数据**，由于缓存是不命中时被动写的，如果从 DB 查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到 DB 去查询，失去了缓存的意义。在流量大时，可能 DB 就挂掉了。

1. 缓存空值，不会查数据库。
2. 采用**布隆过滤器**，将所有可能存在的数据哈希到一个足够大的 bitmap 中，查询不存在的数据会被这个 bitmap 拦截掉，从而避免了对 DB 的查询压力。

布隆过滤器的原理：当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点，把它们置为 1。查询时，将元素通过散列函数映射之后会得到 k 个点，如果这些点有任何一个 0，则被检元素一定不在，直接返回；如果都是 1，则查询元素很可能存在，就会去查询 Redis 和数据库。

## 缓存雪崩

缓存雪崩是指在我们设置缓存时采用了相同的过期时间，**导致缓存在某一时刻同时失效**，请求全部转发到 DB，DB 瞬时压力过重挂掉。

解决方法：在原有的失效时间基础上增加一个**随机值**，使得过期时间分散一些。

## 缓存击穿

缓存击穿：大量的请求同时查询一个 key 时，此时这个 key 正好失效了，就会导致大量的请求都落到数据库。**缓存击穿是查询缓存中失效的 key，而缓存穿透是查询不存在的 key。**

解决方法：加**分布式锁**，第一个请求的线程可以拿到锁，拿到锁的线程查询到了数据之后设置缓存，其他的线程获取锁失败会等待 50ms 然后重新到缓存取数据，这样便可以避免大量的请求落到数据库。

## pipeline 的作用？

redis 客户端执行一条命令分 4 个过程： 发送命令、命令排队、命令执行、返回结果。**使用 pipeline 可以批量请求**，批量返回结果，执行速度比逐条执行要快。

使用 pipeline 组装的命令个数不能太多，不然数据量过大，增加客户端的等待时间，还可能造成网络阻塞，可以将大量命令的拆分多个小的 pipeline 命令完成。

原生批命令（mset 和 mget）与 pipeline 对比：

**原生批命令是原子性，pipeline 是非原子性**。pipeline 命令中途异常退出，之前执行成功的命令不会回滚。

原生批命令只有一个命令，但 pipeline 支持多命令。

## lua 脚本作用

通过Lua脚本可高效地处理CAS（compare-and-set）命令，进一步提升Redis的性能，同时可以轻松实现以前较难实现或者不能高效实现的模式。

1、Lua 脚本在 Redis 中是原子执行的，执行过程中间不会插入其他命令。

2、Lua 脚本可以将多条命令一次性打包，有效地减少网络开销。

### 应用场景

举例：限制接口访问频率。

在 Redis 维护一个接口访问次数的键值对，key 是接口名称，value 是访问次数。每次访问接口时，会执行以下操作：

通过 aop 拦截接口的请求，对接口请求进行计数，每次进来一个请求，相应的接口访问次数 count 加 1，存入 redis。

如果是第一次请求，则会设置 count=1，并设置过期时间。因为这里 set()和 expire()组合操作不是原子操作，所以引入 lua 脚本，实现原子操作，避免并发访问问题。

如果给定时间范围内超过最大访问次数，则会抛出异常。

## 在使用 Redis 作为缓存的时候有没有遇到什么问题呢？

我： 咳咳，是的，确实遇到了以及考虑到了一些问题，比如缓存一致性、雪崩、穿透与击穿，关于 **Redis 与 MySQL 之间的数据一致性问题其实也考虑过很多方案**，比如**_先删后改，延时双删_**等等很多方案，但是在高并发情况下还是会造成数据的不一致性，所以*关于 DB 与缓存之间的强一致性一定要保证的话那么就对于这部分数据不要做缓存，操作直接走 DB*，但是如果这个数据比较热点的话那么还是会给 DB 造成很大的压力，所以在我们的项目中还是采用先删再改+过期的方案来做的，虽然也会存在数据的不一致，但是勉强也能接受，因为毕竟使用缓存访问快的同时也能减轻 DB 压力，而且本身采用缓存就需要接受一定的数据延迟性和短暂的不一致性，我们只能采取合适的策略来降低缓存和数据库间数据不一致的概率，而无法保证两者间的强一致性。合适的策略包括合适的缓存更新策略，合适的缓存淘汰策略，更新数据库后及时更新缓存、缓存失败时增加重试机制等。

### redis 缓存不一致

缓存不一致的情况有两种：

1. Redis 缓存中是旧值；

2. 数据库中值是旧值；

缓存一致性需要保证的是，当缓存中有值的时候，数据库的值必须与缓存一致。

根据是否接收写请求，可以将缓存分为读写缓存和只读缓存。两种发生缓存不一致的情况不同，需要分开来应对。

在只读缓存中，新增数据会直接写到数据库中，不会操作缓存，所以不会出现缓存不一致。删改数据时，需要删除数据库和缓存中的数据，在删改数据库和缓存时，无论哪个先后，中间出现故障都会产生旧值，即缓存不一致的情况。

| 不同情况                     | 潜在问题                                                                               |
| ---------------------------- | -------------------------------------------------------------------------------------- |
| 先删除缓存值，后更新数据库值 | 数据库更新失败，导致请求再次访问缓存时，发现缓存缺失，再读数据库时，从数据库中读到旧值 |
| 先更新数据库值，后删除缓存值 | 缓存删除失败，导致请求再次访问缓存时，发现缓存命中，并从缓存中读取到旧值               |

### 如何解决数据不一致

#### 重试机制

可以将要删除的缓存值或者要更新的数据库值暂存在消息队列中。当应用没有能够成功删除缓存或者更新数据库值时，可以从消息队列中重新读取这些值，然后再次进行删除或更新。

如果能够成功地删除或更新，就需要将这些值从消息队列中去除，以免重复操作。如果重试超过一定次数，还是没有成功，就需要向业务层发送报错信息了。

但重试机制在并发量大时，依旧会有问题。要分先删缓存还是先更新数据库两种情况说说。

#### 情况一：先删缓存，后更新数据库。

在并发的情况下，假设线程 A 先删除缓存，后更新数据库；那么在这期间线程 b 读取数据，发现缓存缺失，就会去数据库读取数据，那么就会产生两个问题：

线程 b 读取到的旧数据；

线程 b 读到旧数据后发现缓存缺失，那么就会去更新缓存，将缓存更新为了旧值，这样后面读取的线程访问的就是旧值，产生了数据不一致；

这样的情况可以采用**延时双删**的策略，**即在线程 A 更新完数据库后，sleep 一段时间，再删除一次缓存**。这样做的目的是为了当线程 b 发现缓存缺失后将缓存更新了旧值，然后将这个旧值缓存给删除掉。

个人觉得这个策略并不是很好的做法。首先延时的时间不好确定，无法得知下一个读线程会更新缓存的时间。其二在并发量大的情况下，当线程 a 还没做延时双删时，会有大量的线程读取到缓存中的旧值。所以觉得这种方案只是会降低缓存不一致的概率，并非是"银弹。

#### 情况二：先更新数据库值，再删除缓存值。

在并发的情况下，假设线程 a 先更新数据库，再删除缓存值。那么在更新数据库后删除缓存值前，会也线程读取到缓存中的旧值。不过由于删除缓存操作是内存操作，所以可以认为这一步是很快的，影响量不会很大。

不过对于正常业务来说，这种短时间内的数据不一致并不会影响很大。如果对于数据一致性要强要求的，要么不使用缓存，要么是利用分布式锁将请求变为串行。具体的做法得分场景选择了。
