---
layout: post
title: Redis 数据库基础
categories: [数据库, 面试]
---

## Redis 是什么？简述它的优缺点？

Redis 本质上是一个 Key-Value（键值对，非关系型）类型的内存数据库，很像 Memcached，整个数据库加载在内存当中操作，定期通过异步操作把数据库中的数据 flush 到硬盘上进行保存。

因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value 数据库。

### 优缺点

优点：

1. **读写性能极高**， Redis 能读的速度是 110000 次/s，写的速度是 81000 次/s。

2. **支持数据持久化**，支持 AOF 和 RDB 两种持久化方式。

3. **支持事务**， Redis 的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来。

4. **数据结构丰富**，除了支持 string 类型的 value 外，还支持 hash、set、zset、list 等数据结构。

5. **支持主从复制**，主机会自动将数据同步到从机，可以进行读写分离。

6. **丰富的特性** – Redis 还支持 publish/subscribe， 通知， key 过期等特性。

7. Redis 是**单线程**的，避免线程切换开销及多线程的竞争问题。单线程是指网络请求使用一个线程来处理，Redis 运行是不止有一个线程，比如数据持久化的过程会另起线程。

缺点：

1. 数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在**较小数据量**的高性能操作和运算上。

2. 主机宕机，**宕机前有部分数据未能及时同步到从机，切换 IP 后还会引入数据不一致的问题**，降低了系统的可用性。

## Redis 为什么这么快？

1. 内存存储：Redis 是使用内存(in-memeroy)存储，没有磁盘 IO 上的开销。_数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O(1)_。

2. 单线程实现（ Redis 6.0 以前）：_Redis 使用单个线程处理请求，避免了多个线程之间线程切换和锁资源争用的开销_。注意：单线程是指的是在核心网络模型中，网络请求模块使用一个线程来处理，即一个线程处理所有网络请求。

3. 非阻塞 IO：_Redis 使用多路复用 IO 技术_，将 epoll 作为 I/O 多路复用技术的实现，_再加上 Redis 自身的事件处理模型将 epoll 中的连接、读写、关闭都转换为事件，不在网络 I/O 上浪费过多的时间_。

4. 优化的数据结构：Redis 每种数据类型底层都做了优化，目的就是为了追求更快的速度。

5. 使用底层模型不同：Redis 直接自己*构建了 VM (虚拟内存)机制*，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

6. Redis 的 VM(虚拟内存)机制就是暂时把不经常访问的数据(冷数据)从内存交换到磁盘中，从而腾出宝贵的内存空间用于其它需要访问的数据(热数据)。通过*VM 功能可以实现冷热数据分离，使热数据仍在内存中、冷数据保存到磁盘*。这样就可以避免因为内存不足而造成访问速度下降的问题。

7. Redis 提高数据库容量的办法有两种：_一种是可以将数据分割到多个 RedisServer 上；另一种是使用虚拟内存把那些不经常访问的数据交换到磁盘上_。需要特别注意的是**Redis 并没有使用 OS 提供的 Swap，而是自己实现**。

## Redis 为何选择单线程？

1. 避免过多的上下文切换开销。程序始终运行在进程中单个线程内，没有多线程切换的场景。

2. 避免同步机制的开销：如果 Redis 选择多线程模型，需要考虑数据同步的问题，则必然会引入某些同步机制，会导致在操作数据过程中带来更多的开销，增加程序复杂度的同时还会降低性能。

3. 实现简单，方便维护：如果 Redis 使用多线程模式，那么所有的底层数据结构的设计都必须考虑线程安全问题，那么 Redis 的实现将会变得更加复杂。

## Redis 应用场景有哪些？

1. 缓存热点数据，缓解数据库的压力。

2. 利用 Redis 原子性的自增操作，可以实现计数器的功能，比如统计用户点赞数、用户访问数等。

3. 简单的消息队列，可以使用 Redis 自身的发布/订阅模式或者 List 来实现简单的消息队列，实现异步操作。

4. 限速器，可用于限制某个用户访问某个接口的频率，比如秒杀场景用于防止用户快速点击带来不必要的压力。

5. 好友关系，利用集合的一些命令，比如交集、并集、差集等，实现共同好友、共同爱好之类的功能。

## Memcached 和 Redis 的区别？

1. Redis 只使用单核，而 Memcached 可以使用多核。
2. MemCached 数据结构单一，仅用来缓存数据，而 Redis 支持多种数据类型。
3. MemCached 不支持数据持久化，重启后数据会消失。Redis 支持数据持久化。
4. Redis 提供主从同步机制和 cluster 集群部署能力，能够提供高可用服务。Memcached 没有提供原生的集群模式，需要依靠客户端实现往集群中分片写入数据。
5. Redis 的速度比 Memcached 快很多。
6. Redis 使用单线程的多路 IO 复用模型，Memcached 使用多线程的非阻塞 IO 模型。

## Redis 数据类型有哪些？

### 基本数据类型：

1. String：最常用的一种数据类型，String 类型的值可以是字符串、数字或者二进制，但值最大不能超过 512MB。

2. Hash：Hash 是一个键值对集合。

3. Set：无序去重的集合。Set 提供了交集、并集等方法，对于实现共同好友、共同关注等功能特别方便。

4. List：有序可重复的集合，底层是依赖双向链表实现的。

5. SortedSet：有序 Set。内部维护了一个 score 的参数来实现。适用于排行榜和带权重的消息队列等场景。

### 特殊的数据类型：

1. Bitmap：位图，可以认为是一个以位为单位数组，数组中的每个单元只能存 0 或者 1，数组的下标在 Bitmap 中叫做偏移量。Bitmap 的长度与集合中元素个数无关，而是与基数的上限有关。

2. Hyperloglog。HyperLogLog 是用来做基数统计的算法，其优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。典型的使用场景是统计独立访客。

3. Geospatial ：主要用于存储地理位置信息，并对存储的信息进行操作，适用场景如定位、附近的人等。

## Redis 事务

事务的原理是将一个事务范围内的若干命令发送给 Redis，然后再让 Redis 依次执行这些命令。

事务的生命周期：

1. 使用 MULTI 开启一个事务；
2. 在开启事务的时候，每次操作的命令将会被插入到一个队列中，同时这个命令并不会被真正执行；
3. EXEC 命令进行提交事务。

![20230315110758](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230315110758.png)

一个事务范围内某个命令出错不会影响其他命令的执行，不保证原子性：

```bash
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set a 1
QUEUED
127.0.0.1:6379> set b 1 2
QUEUED
127.0.0.1:6379> set c 3
QUEUED
127.0.0.1:6379> exec
1) OK
2) (error) ERR syntax error
3) OK
```

### WATCH 命令

WATCH 命令可以监控一个或多个键，一旦其中有一个键被修改，之后的事务就不会执行（类似于乐观锁）。执行 EXEC 命令之后，就会自动取消监控。

```
127.0.0.1:6379> watch name
OK
127.0.0.1:6379> set name 1
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set name 2
QUEUED
127.0.0.1:6379> set gender 1
QUEUED
127.0.0.1:6379> exec
(nil)
127.0.0.1:6379> get gender
(nil)
```

比如上面的代码中：

watch name 开启了对 name 这个 key 的监控

修改 name 的值

开启事务 a

在事务 a 中设置了 name 和 gender 的值

使用 EXEC 命令进提交事务

使用命令 get gender 发现不存在，即事务 a 没有执行

使用 UNWATCH 可以取消 WATCH 命令对 key 的监控，所有监控锁将会被取消。

## 持久化机制

持久化就是把内存的数据写到磁盘中，防止服务宕机导致内存数据丢失。

Redis 支持两种方式的持久化，一种是 RDB 的方式，一种是 AOF 的方式。前者会根据指定的规则定时将内存中的数据存储在硬盘上，而后者在每次执行完命令后将命令记录下来。一般将两者结合使用。

### RDB 方式

RDB 是 Redis 默认的持久化方案。_RDB 持久化时会将内存中的数据写入到磁盘中，在指定目录下生成一个 dump.rdb 文件_。Redis 重启会加载 dump.rdb 文件恢复数据。

#### bgsave 是主流的触发 RDB 持久化的方式，执行过程如下：

1. 执行 BGSAVE 命令
2. Redis 父进程判断当前是否存在正在执行的子进程，如果存在，BGSAVE 命令直接返回。
3. 父进程执行 fork 操作创建子进程，fork 操作过程中父进程会阻塞。
4. 父进程 fork 完成后，父进程继续接收并处理客户端的请求，而子进程开始将内存中的数据写进硬盘的临时文件；
5. 当子进程写完所有数据后会用该临时文件替换旧的 RDB 文件。

Redis 启动时会读取 RDB 快照文件，将数据从硬盘载入内存。通过 RDB 方式的持久化，一旦 Redis 异常退出，就会丢失最近一次持久化以后更改的数据。

#### 触发 RDB 持久化的方式：

1. 手动触发：用户执行 SAVE 或 BGSAVE 命令。SAVE 命令执行快照的过程会阻塞所有客户端的请求，应避免在生产环境使用此命令。BGSAVE 命令可以在后台异步进行快照操作，快照的同时服务器还可以继续响应客户端的请求，因此需要手动执行快照时推荐使用 BGSAVE 命令。

2. 被动触发：
   根据配置规则进行自动快照，如 SAVE 100 10，100 秒内至少有 10 个键被修改则进行快照。
   如果从节点执行全量复制操作，主节点会自动执行 BGSAVE 生成 RDB 文件并发送给从节点。
   默认情况下执行 shutdown 命令时，如果没有开启 AOF 持久化功能则自动执行·BGSAVE·。

#### 优缺点

优点：

Redis **加载 RDB 恢复数据远远快于 AOF 的方式**。

使用**单独子进程来进行持久化**，主进程不会进行任何 IO 操作，保证了 Redis 的高性能。

缺点：

RDB 方式数据无法做到实时持久化。因为 BGSAVE 每次运行都要执行 fork 操作创建子进程，属于重量级操作，频繁执行成本比较高。

RDB 文件使用特定二进制格式保存，Redis 版本升级过程中有多个格式的 RDB 版本，存在老版本 Redis 无法兼容新版 RDB 格式的问题。

### AOF 方式

AOF（append only file）持久化：**以独立日志的方式记录每次写命令**，Redis 重启时会重新执行 AOF 文件中的命令达到恢复数据的目的。AOF 的主要作用是**解决了数据持久化的实时性，AOF 是 Redis 持久化的主流方式**。

默认情况下 Redis 没有开启 AOF 方式的持久化，可以通过 **appendonly** 参数启用：appendonly yes。开启 AOF 方式持久化后每执行一条写命令，Redis 就会将该命令写进 aof_buf 缓冲区，AOF 缓冲区根据对应的策略向硬盘做同步操作。

默认情况下系统每 30 秒会执行一次同步操作。为了防止缓冲区数据丢失，可以在 Redis 写入 AOF 文件后主动要求系统将缓冲区数据同步到硬盘上。可以通过 appendfsync 参数设置同步的时机。

```
appendfsync always //每次写入aof文件都会执行同步，最安全最慢，不建议配置
appendfsync everysec  //既保证性能也保证安全，建议配置
appendfsync no //由操作系统决定何时进行同步操作
```

### 接下来看一下 AOF 持久化执行流程：

1. 所有的写入命令会追加到 AOP 缓冲区中。
2. AOF 缓冲区根据对应的策略向硬盘同步。
3. 随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩文件体积的目的。AOF 文件重写是把 Redis 进程内的数据转化为写命令同步到新 AOF 文件的过程。
4. 当 Redis 服务器重启时，可以加载 AOF 文件进行数据恢复。

优点：

AOF 可以更好的保护数据不丢失，可以配置 AOF 每秒执行一次 fsync 操作，如果 Redis 进程挂掉，最多丢失 1 秒的数据。

AOF 以 append-only 的模式写入，所以没有磁盘寻址的开销，写入性能非常高。

缺点：

对于同一份文件 AOF 文件比 RDB 数据快照要大。

数据恢复比较慢。

## 主从复制

Redis 的复制功能是支持多个数据库之间的数据同步。主数据库可以进行读写操作，当主数据库的数据发生变化时会自动将数据同步到从数据库。**从数据库一般是只读的，它会接收主数据库同步过来的数据**。_一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库_。

```sh
redis-server //启动Redis实例作为主数据库
redis-server --port 6380 --slaveof  127.0.0.1 6379  //启动另一个实例作为从数据库
slaveof 127.0.0.1 6379
SLAVEOF NO ONE //停止接收其他数据库的同步并转化为主数据库。
```

### 主从复制的原理？

1. 当启动一个从节点时，它会发送一个 PSYNC 命令给主节点；
2. 如果是从节点初次连接到主节点，那么会**触发一次全量复制**。此时主节点会启动一个后台线程，开始**生成一份 RDB 快照文件**；
3. 同时还会将从客户端 client 新收到的所有写命令缓存在内存中。RDB 文件生成完毕后， 主节点会将 RDB 文件发送给从节点，从节点会先将 RDB 文件写入本地磁盘，然后再从本地磁盘加载到内存中；
4. 接着主节点会将内存中缓存的写命令发送到从节点，从节点同步这些数据；
5. 如果从节点跟主节点之间网络出现故障，连接断开了，会自动重连，连接之后主节点仅会将部分缺失的数据同步给从节点。

## 哨兵 Sentinel

主从复制存在不能自动故障转移、达不到高可用的问题。**哨兵模式解决了这些问题。通过哨兵机制可以自动切换主从节点。**

客户端连接 Redis 的时候，先连接哨兵，_哨兵会告诉客户端 Redis 主节点的地址_，然后客户端连接上 Redis 并进行后续的操作。_当主节点宕机的时候，哨兵监测到主节点宕机，会重新推选出某个表现良好的从节点成为新的主节点_，然后通过发布订阅模式通知其他的从服务器，让它们切换主机。

![20230315140729](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230315140729.png)

### 工作原理

每个 Sentinel 以每秒钟一次的频率向它所知道的 Master，Slave 以及其他 Sentinel 实例发送一个 PING 命令。

如果一个实例距离最后一次有效回复 PING 命令的时间超过指定值， 则这个实例会被 Sentine 标记为主观下线。

如果一个 Master 被标记为主观下线，则正在监视这个 Master 的所有 Sentinel 要以每秒一次的频率确认 Master 是否真正进入主观下线状态。

当有足够数量的 Sentinel（大于等于配置文件指定值）在指定的时间范围内确认 Master 的确进入了主观下线状态， 则 Master 会被标记为客观下线 。若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被解除。 若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。

哨兵节点会选举出哨兵 leader，负责故障转移的工作。

哨兵 leader 会推选出某个表现良好的从节点成为新的主节点，然后通知其他从节点更新主节点信息。

## Redis cluster

哨兵模式解决了主从复制不能自动故障转移、达不到高可用的问题，但还是**存在主节点的写能力、容量受限于单机配置的问题**。而 **cluster 模式实现了 Redis 的分布式存储**，每个节点存储不同的内容，解决主节点的写能力、容量受限于单机配置的问题。

Redis cluster 集群节点最小配置 6 个节点以上（3 主 3 从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。

Redis cluster 采用**虚拟槽分区**，所有的键根据**哈希函数**映射到 0 ～ 16383 个整数槽内，_每个节点负责维护一部分槽以及槽所映射的键值数据。_

优点：

1. 无中心架构，支持动态扩容；
2. 数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布；
3. 高可用性。部分节点不可用时，集群仍可用。集群模式能够实现自动故障转移（failover），节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色转换。

缺点：

1. **不支持批量操作**（pipeline）。
2. **数据通过异步复制，不保证数据的强一致性**。
3. 事务操作支持有限，只支持多 key 在同一节点上的事务操作，当多个 key 分布于不同的节点上时无法使用事务功能。
4. key 作为数据分区的最小粒度，不能将一个很大的键值对象如 hash、list 等映射到不同的节点。
5. 不支持多数据库空间，单机下的 Redis 可以支持到 16 个数据库，集群模式下只能使用 1 个数据库空间。

## 过期键的删除策略？

1. 被动删除。在访问 key 时，如果发现 key 已经过期，那么会将 key 删除。

2. 主动删除。定时清理 key，每次清理会依次遍历所有 DB，从 db 随机取出 20 个 key，如果过期就删除，如果其中有 5 个 key 过期，那么就继续对这个 db 进行清理，否则开始清理下一个 db。

3. 内存不够时清理。Redis 有最大内存的限制，通过 maxmemory 参数可以设置最大内存，当使用的内存超过了设置的最大内存，就要进行内存释放， 在进行内存释放的时候，会按照配置的淘汰策略清理内存。

## 内存淘汰策略有哪些？

当 Redis 的内存超过最大允许的内存之后，Redis 会触发内存淘汰策略，删除一些不常用的数据，以保证 Redis 服务器正常运行。

Redisv4.0 前提供 6 种数据淘汰策略：

1. volatile-lru：LRU（Least Recently Used），最近使用。利用 LRU 算法移除设置了过期时间的 key
2. allkeys-lru：当内存不足以容纳新写入数据时，从数据集中移除最近最少使用的 key
3. volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰
4. volatile-random：从已设置过期时间的数据集中任意选择数据淘汰
5. allkeys-random：从数据集中任意选择数据淘汰
6. no-eviction：禁止删除数据，当内存不足以容纳新写入数据时，新写入操作会报错

Redisv4.0 后增加以下两种：

1. volatile-lfu：LFU，Least Frequently Used，最少使用，从已设置过期时间的数据集中挑选最不经常使用的数据淘汰。
2. allkeys-lfu：当内存不足以容纳新写入数据时，从数据集中移除最不经常使用的 key。
3. 内存淘汰策略可以通过配置文件来修改，相应的配置项是 maxmemory-policy，默认配置是 noeviction。

## 如何保证缓存与数据库双写时的数据一致性？

1. 先删除缓存再更新数据库

   进行更新操作时，先删除缓存，然后更新数据库，后续的请求再次读取时，会从数据库读取后再将新数据更新到缓存。

   存在的问题：删除缓存数据之后，更新数据库完成之前，这个时间段内如果有新的读请求过来，就会从数据库读取旧数据重新写到缓存中，再次造成不一致，并且后续读的都是旧数据。

2. 先更新数据库再删除缓存

   进行更新操作时，先更新 MySQL，成功之后，删除缓存，后续读取请求时再将新数据回写缓存。

   存在的问题：更新 MySQL 和删除缓存这段时间内，请求读取的还是缓存的旧数据，不过等数据库更新完成，就会恢复一致，影响相对比较小。

3. 异步更新缓存

   数据库的更新操作完成后不直接操作缓存，而是把这个操作命令封装成消息扔到消息队列中，然后由 Redis 自己去消费更新数据，消息队列可以保证数据操作顺序一致性，确保缓存系统的数据正常。

## 缓存穿透

缓存穿透是指查询一个**不存在的数据**，由于缓存是不命中时被动写的，如果从 DB 查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到 DB 去查询，失去了缓存的意义。在流量大时，可能 DB 就挂掉了。

1. 缓存空值，不会查数据库。
2. 采用**布隆过滤器**，将所有可能存在的数据哈希到一个足够大的 bitmap 中，查询不存在的数据会被这个 bitmap 拦截掉，从而避免了对 DB 的查询压力。

布隆过滤器的原理：当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点，把它们置为 1。查询时，将元素通过散列函数映射之后会得到 k 个点，如果这些点有任何一个 0，则被检元素一定不在，直接返回；如果都是 1，则查询元素很可能存在，就会去查询 Redis 和数据库。

## 缓存雪崩

缓存雪崩是指在我们设置缓存时采用了相同的过期时间，**导致缓存在某一时刻同时失效**，请求全部转发到 DB，DB 瞬时压力过重挂掉。

解决方法：在原有的失效时间基础上增加一个**随机值**，使得过期时间分散一些。

## 缓存击穿

缓存击穿：大量的请求同时查询一个 key 时，此时这个 key 正好失效了，就会导致大量的请求都落到数据库。**缓存击穿是查询缓存中失效的 key，而缓存穿透是查询不存在的 key。**

解决方法：加**分布式锁**，第一个请求的线程可以拿到锁，拿到锁的线程查询到了数据之后设置缓存，其他的线程获取锁失败会等待 50ms 然后重新到缓存取数据，这样便可以避免大量的请求落到数据库。

## pipeline 的作用？

redis 客户端执行一条命令分 4 个过程： 发送命令、命令排队、命令执行、返回结果。**使用 pipeline 可以批量请求**，批量返回结果，执行速度比逐条执行要快。

使用 pipeline 组装的命令个数不能太多，不然数据量过大，增加客户端的等待时间，还可能造成网络阻塞，可以将大量命令的拆分多个小的 pipeline 命令完成。

原生批命令（mset 和 mget）与 pipeline 对比：

**原生批命令是原子性，pipeline 是非原子性**。pipeline 命令中途异常退出，之前执行成功的命令不会回滚。

原生批命令只有一个命令，但 pipeline 支持多命令。

## lua 脚本作用

1、Lua 脚本在 Redis 中是原子执行的，执行过程中间不会插入其他命令。

2、Lua 脚本可以将多条命令一次性打包，有效地减少网络开销。

### 应用场景

举例：限制接口访问频率。

在 Redis 维护一个接口访问次数的键值对，key 是接口名称，value 是访问次数。每次访问接口时，会执行以下操作：

通过 aop 拦截接口的请求，对接口请求进行计数，每次进来一个请求，相应的接口访问次数 count 加 1，存入 redis。

如果是第一次请求，则会设置 count=1，并设置过期时间。因为这里 set()和 expire()组合操作不是原子操作，所以引入 lua 脚本，实现原子操作，避免并发访问问题。

如果给定时间范围内超过最大访问次数，则会抛出异常。
