---
layout: post
title: 数据结构基础
categories: [数据结构, 面试]
---

## ⼗⼤排序算法及其时间和空间复杂度

![20230315161545](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230315161545.png)

1. 桶排序

   算法描述：将数组分到有限数量的桶⾥。每个桶再个别排序（有可能再使⽤别的排序算法或是以递归⽅式继续使⽤
   桶排序进⾏排序）。

   ```c
   void bucketSort(std::vector<int>& nums) {
        if (nums.empty()) return ;
        int low = *std::min_element(nums.begin(), nums.end());
        int high = *std::max_element(nums.begin(), nums.end());
        int n = high - low + 1;
        std::vector<int> buckets(n);
        std::vector<int> res;
        for (auto x : nums) ++buckets[x - low];
        for (int i = 0; i < n; ++i) { //实现了按桶下标从⼩到达输出
            for (int j = 0; j < buckets[i]; ++j) { //重复的输出
                res.push_back(i + low);
            }
        }
        for (int i=0; i<res.size(); ++i) {
            std::cout<<res[i]<<" ";
        }
   }
   ```

2. 计数排序

   扩展：如果在⾯试中有⾯试官要求你写⼀个 O(n) 时间复杂度的排序算法，可不要傻乎乎的说这不可能！虽然前⾯
   基于⽐较的排序的下限是 O(nlogn)。但是确实也有线性时间复杂度的排序，只不过有前提条件，就是待排序的数要
   满⾜⼀定的范围的整数，⽽且计数排序需要⽐较多的辅助空间。

   算法描述：**其基本思想是，⽤待排序的数作为计数数组的下标，统计每个数字的个数。然后依次输出即可得到有序序列**。

   假设有 8 个考⽣，分数在 0 到 5 分之间。这 8 个考⽣的成绩我们放在⼀个数组 A[8]中，它们分别是： 2， 5， 3，
   0， 2， 3， 0， 3。

   考⽣的成绩从 0 到 5 分，我们使⽤⼤⼩为 6 的数组 C[6]表示桶，其中下标对应分数。不过， C[6]内存储的并不是考
   ⽣，⽽是对应的考⽣个数。像我刚刚举的那个例⼦，我们只需要遍历⼀遍考⽣分数，就可以得到 C[6]的值。

   ![20230315162228](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230315162228.png)

   这是我们的数组，从图中可以看出，分数为 3 分的考⽣有 3 个，⼩于 3 分的考⽣有 4 个，所以，成绩为 3 分的考
   ⽣在排序之后的有序数组 R[8]中，会保存下标 4， 5， 6 的位置。

   那我们如何快速计算出，每个分数的考⽣在有序数组中对应的存储位置呢？

   我们对 C[6] 数组顺序求和， C[6]存储的数据就变成了下⾯这样⼦。 **C[k]⾥存储⼩于等于分数 k 的考⽣个数。**

   ![20230315162335](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230315162335.png)

   我们从后到前依次扫描数组 A。⽐如，当扫描到 3 时，我们可以从数组 C 中取出下标为 3 的值 7，也就是说，到⽬
   前为⽌，包括⾃⼰在内，分数⼩于等于 3 的考⽣有 7 个，也就是说 3 是数组 R 中的第 7 个元素（也就是数组 R 中
   下标为 6 的位置）。当 3 放⼊到数组 R 中后，⼩于等于 3 的元素就只剩下了 6 个了，所以相应的 C[3]要减 1，变
   成 6。

   以此类推，当我们扫描到第 2 个分数为 3 的考⽣的时候，就会把它放⼊数组 R 中的第 6 个元素的位置（也就是下
   标为 5 的位置）。当我们扫描完整个数组 A 后，数组 R 内的数据就是按照分数从⼩到⼤有序排列的了。

   注意：计数排序只能⽤在数据范围不⼤的场景中，如果数据范围 k ⽐要排序的数据 n ⼤很多，就不适合⽤计数排序
   了。⽽且，计数排序只能给⾮负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对⼤⼩的情况下，
   转化为⾮负整数。

   ```c
    void countSort(int *a,int n){
        int maxV=a[0];
        for(int i=1; i<n; ++i){
            maxV=max(maxV,a[i]);
        }
        int c[maxn];
        memset(c,0,sizeof(c));
        for(int i=0; i<n; ++i){
            c[a[i]]++;
        }
        for(int i=1; i<=maxV; ++i){
            c[i]+=c[i-1];
        }
        int r[maxn];
        memset(r,0,sizeof(r));
        for(int i=n-1; i>=0; --i){
            int index = c[a[i]]-1;
            r[index]=a[i];
            c[a[i]]--;
        }
        for(int i=0; i<n; ++i){
            a[i]=r[i];
        }
    }
   ```

## 说⼀下红⿊树（RB-tree）

前面我们已经说过，红黑树，本质上来说就是一棵二叉查找树，但它在二叉查找树的基础上**增加了着色和相关的性质使得红黑树相对平衡**，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。但它是如何保证一棵n个结点的红黑树的高度始终保持在h = logn的呢？

红⿊树的定义：

性质 1：每个节点要么是⿊⾊，要么是红⾊。

性质 2：根节点是⿊⾊。

性质 3：每个叶⼦节点（NIL）是⿊⾊。

性质 4：每个红⾊结点的两个⼦结点⼀定都是⿊⾊。

性质 5：任意⼀结点到每个叶⼦结点的路径都包含数量相同的⿊结点。

## B+ 树

B+树是在 B 树的基础上又一次的改进，其主要对两个方面进行了提升，一方面是查询的稳定性，另外一方面是在数据排序方面更友好。

### B+树构建规则

（1）B+树的非叶子节点不保存具体的数据，而只保存关键字的索引，而所有的数据最终都会保存到叶子节点。因为所有数据必须要到叶子节点才能获取到，所以每次数据查询的次数都一样，这样一来 B+树的查询速度也就会比较稳定
