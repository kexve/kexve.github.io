---
layout: post
title: 数据库基础
categories: [数据库, 面试]
---

## Redis 是什么？简述它的优缺点？

Redis 本质上是一个 Key-Value（键值对，非关系型）类型的内存数据库，很像 Memcached，整个数据库加载在内存当中操作，定期通过异步操作把数据库中的数据 flush 到硬盘上进行保存。

因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value 数据库。

### 优缺点

优点：

1. **读写性能极高**， Redis 能读的速度是 110000 次/s，写的速度是 81000 次/s。

2. **支持数据持久化**，支持 AOF 和 RDB 两种持久化方式。

3. **支持事务**， Redis 的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来。

4. **数据结构丰富**，除了支持 string 类型的 value 外，还支持 hash、set、zset、list 等数据结构。

5. **支持主从复制**，主机会自动将数据同步到从机，可以进行读写分离。

6. **丰富的特性** – Redis 还支持 publish/subscribe， 通知， key 过期等特性。

7. Redis 是**单线程**的，避免线程切换开销及多线程的竞争问题。单线程是指网络请求使用一个线程来处理，Redis 运行是不止有一个线程，比如数据持久化的过程会另起线程。

缺点：

1. 数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在**较小数据量**的高性能操作和运算上。

2. 主机宕机，**宕机前有部分数据未能及时同步到从机，切换 IP 后还会引入数据不一致的问题**，降低了系统的可用性。

## Redis 为什么这么快？

1. 内存存储：Redis 是使用内存(in-memeroy)存储，没有磁盘 IO 上的开销。_数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O(1)_。

2. 单线程实现（ Redis 6.0 以前）：_Redis 使用单个线程处理请求，避免了多个线程之间线程切换和锁资源争用的开销_。注意：单线程是指的是在核心网络模型中，网络请求模块使用一个线程来处理，即一个线程处理所有网络请求。

3. 非阻塞 IO：_Redis 使用多路复用 IO 技术_，将 epoll 作为 I/O 多路复用技术的实现，_再加上 Redis 自身的事件处理模型将 epoll 中的连接、读写、关闭都转换为事件，不在网络 I/O 上浪费过多的时间_。

4. 优化的数据结构：Redis 每种数据类型底层都做了优化，目的就是为了追求更快的速度。

5. 使用底层模型不同：Redis 直接自己*构建了 VM (虚拟内存)机制*，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

6. Redis 的 VM(虚拟内存)机制就是暂时把不经常访问的数据(冷数据)从内存交换到磁盘中，从而腾出宝贵的内存空间用于其它需要访问的数据(热数据)。通过*VM 功能可以实现冷热数据分离，使热数据仍在内存中、冷数据保存到磁盘*。这样就可以避免因为内存不足而造成访问速度下降的问题。

7. Redis 提高数据库容量的办法有两种：_一种是可以将数据分割到多个 RedisServer 上；另一种是使用虚拟内存把那些不经常访问的数据交换到磁盘上_。需要特别注意的是**Redis 并没有使用 OS 提供的 Swap，而是自己实现**。

## Redis 为何选择单线程？

1. 避免过多的上下文切换开销。程序始终运行在进程中单个线程内，没有多线程切换的场景。

2. 避免同步机制的开销：如果 Redis 选择多线程模型，需要考虑数据同步的问题，则必然会引入某些同步机制，会导致在操作数据过程中带来更多的开销，增加程序复杂度的同时还会降低性能。

3. 实现简单，方便维护：如果 Redis 使用多线程模式，那么所有的底层数据结构的设计都必须考虑线程安全问题，那么 Redis 的实现将会变得更加复杂。

## Redis 应用场景有哪些？

1. 缓存热点数据，缓解数据库的压力。

2. 利用 Redis 原子性的自增操作，可以实现计数器的功能，比如统计用户点赞数、用户访问数等。

3. 简单的消息队列，可以使用 Redis 自身的发布/订阅模式或者 List 来实现简单的消息队列，实现异步操作。

4. 限速器，可用于限制某个用户访问某个接口的频率，比如秒杀场景用于防止用户快速点击带来不必要的压力。

5. 好友关系，利用集合的一些命令，比如交集、并集、差集等，实现共同好友、共同爱好之类的功能。

## Memcached 和 Redis 的区别？

1. Redis 只使用单核，而 Memcached 可以使用多核。
2. MemCached 数据结构单一，仅用来缓存数据，而 Redis 支持多种数据类型。
3. MemCached 不支持数据持久化，重启后数据会消失。Redis 支持数据持久化。
4. Redis 提供主从同步机制和 cluster 集群部署能力，能够提供高可用服务。Memcached 没有提供原生的集群模式，需要依靠客户端实现往集群中分片写入数据。
5. Redis 的速度比 Memcached 快很多。
6. Redis 使用单线程的多路 IO 复用模型，Memcached 使用多线程的非阻塞 IO 模型。

## Redis 数据类型有哪些？

### 基本数据类型：

1. String：最常用的一种数据类型，String 类型的值可以是字符串、数字或者二进制，但值最大不能超过 512MB。

2. Hash：Hash 是一个键值对集合。

3. Set：无序去重的集合。Set 提供了交集、并集等方法，对于实现共同好友、共同关注等功能特别方便。

4. List：有序可重复的集合，底层是依赖双向链表实现的。

5. SortedSet：有序 Set。内部维护了一个 score 的参数来实现。适用于排行榜和带权重的消息队列等场景。

### 特殊的数据类型：

1. Bitmap：位图，可以认为是一个以位为单位数组，数组中的每个单元只能存 0 或者 1，数组的下标在 Bitmap 中叫做偏移量。Bitmap 的长度与集合中元素个数无关，而是与基数的上限有关。

2. Hyperloglog。HyperLogLog 是用来做基数统计的算法，其优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。典型的使用场景是统计独立访客。

3. Geospatial ：主要用于存储地理位置信息，并对存储的信息进行操作，适用场景如定位、附近的人等。

## Redis 事务

事务的原理是将一个事务范围内的若干命令发送给 Redis，然后再让 Redis 依次执行这些命令。

事务的生命周期：

1. 使用 MULTI 开启一个事务；
2. 在开启事务的时候，每次操作的命令将会被插入到一个队列中，同时这个命令并不会被真正执行；
3. EXEC 命令进行提交事务。

![20230315110758](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20230315110758.png)

一个事务范围内某个命令出错不会影响其他命令的执行，不保证原子性：

```bash
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set a 1
QUEUED
127.0.0.1:6379> set b 1 2
QUEUED
127.0.0.1:6379> set c 3
QUEUED
127.0.0.1:6379> exec
1) OK
2) (error) ERR syntax error
3) OK
```

### WATCH 命令

WATCH 命令可以监控一个或多个键，一旦其中有一个键被修改，之后的事务就不会执行（类似于乐观锁）。执行 EXEC 命令之后，就会自动取消监控。

```
127.0.0.1:6379> watch name
OK
127.0.0.1:6379> set name 1
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set name 2
QUEUED
127.0.0.1:6379> set gender 1
QUEUED
127.0.0.1:6379> exec
(nil)
127.0.0.1:6379> get gender
(nil)
```

比如上面的代码中：

watch name 开启了对 name 这个 key 的监控

修改 name 的值

开启事务 a

在事务 a 中设置了 name 和 gender 的值

使用 EXEC 命令进提交事务

使用命令 get gender 发现不存在，即事务 a 没有执行

使用 UNWATCH 可以取消 WATCH 命令对 key 的监控，所有监控锁将会被取消。
