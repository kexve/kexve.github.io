---
layout: post
title: 语法分析器实现尝试
categories: 编译原理
---

## 基本概念

![20221117160833](https://cdn.jsdelivr.net/gh/kexve/img@main/image_blog20221117160833.png)

词法分析器 (Lexer)  词法分析是指在计算机科学中，将字符序列转换为单词(Token)的过程。词法分析器(Lexer)一般是用来供语法解析器(Parser)调用的。

语法解析器 (Parser) 语法解析器通常作为编译器或解释器出现。它的作用是进行语法检查，并构建由输入单词(Token)组成的数据结构(即抽象语法树)。语法解析器通常使用词法分析器(Lexer)从输入字符流中分离出一个个的单词(Token)，并将单词(Token)流作为其输入。实际开发中，语法解析器可以手工编写，也可以使用工具自动生成。

抽象语法树 (Abstract Syntax Tree,AST) 抽象语法树是源代码结构的一种抽象表示，它以树的形状表示语言的语法结构。抽象语法树一般可以用来进行代码语法的检查，代码风格的检查，代码的格式化，代码的高亮，代码的错误提示以及代码的自动补全等等。

## 怎么表示语法

正如我们通过一段文字描述某种游戏规则一样，我们也可以用一段文字来描述一个语法。请看：

```txt
句子的语法：

    1. 一个句子，由主语 + 谓语 + 宾语构成
    2. 主语是：“程序员”
    3. 谓语是：“没有”
    4. 宾语是：“头发”
```

显然，这就是一套语法了。但是我们发现，这种白话文式的语法表示显然不是我们编译器一贯的作风嘛。针对这个问题，巴科斯及后人提出了用于表示语法的“巴科斯范式”和“拓展的巴科斯范式”。拓展的巴科斯范式的主要规则如下：

```
    1. 用“::=”符号表示“是”，或“由...构成”的意思。说的专业点，叫“推导出”
    2. 用“|”符号表示“或”的意思
    3. 用“[ ... ]”表示中括号中的内容是可选的
    4. 用“{ ... }”表示大括号中的内容可以出现0至无穷多次的重复
```

现在，就让我们用“拓展的巴科斯范式”来描述我们的语法吧：

```
句子的语法：

    1. 句子 ::= 主语 谓语 宾语
    2. 主语 ::= “程序员”
    3. 谓语 ::= “没有”
    4. 宾语 ::= “头发”
```

## 语法怎么使用

正如前面的章节所说，此时，我们就可以将这段记号流立体化，变为一棵抽象语法树了。这棵抽象语法树长什么样呢。请看：

```
                   句子
      /             |           \

    程序员（主语） 没有（谓语） 头发（宾语）
```

一句话解释：语法长什么样，语法树就长什么样。

将上面的模型变为代码，我们就得到了抽象语法树节点的定义。请看：

```c++
struct AST
{
    // Attribute
    TOKEN_TYPE tokenType;
    string tokenStr;
    vector<AST *> subList;
    int lineNo;


    // Constructor
    explicit AST(TOKEN_TYPE _tokenType, const string &_tokenStr = "",
        const vector<AST *> &_subList = {}, int _lineNo = 0);

    explicit AST(const Token *tokenPtr);


    // Destructor
    ~AST();
};
```

可见，抽象语法树节点的定义和前面 Token 类的定义是高度相似的。抽象语法树节点也需要标记的类别、标记字符串，以及标记所在的行数。此外，抽象语法树节点还需要一个 vector，以保存这个节点的所有子节点。

## 消除左递归

这巴科斯范式可不是省油的灯啊。这一节和下一节，我们将分别来看看巴科斯范式中的两个常见问题。首先来看消除左递归。

假设有以下语法：

```
    Six ::= Six '6'
          | '6'
```

这个语法说了什么？其表示，一个“Six”可以推导出一个“Six '6'”；而“Six”又是什么？是“Six '6'”；而“Six”又是什么？是“Six '6'”...

怎么回事？我们连一个记号字符串都还没看到呢，就光顾着在这无限循环了，这就是“左递归”问题，是我们需要消除的。

怎么消除呢？首先需要明确的是，语法表示并不是神圣不可侵犯的，而是可以进行等价变换的。那么，上面这个语法该怎么变换呢？让我们来找找规律：

```
    1. Six ::= '6'
    2. Six ::= Six '6' ::= '6' '6'
    3. Six ::= Six '6' ::= Six '6' '6' ::= '6' '6' '6'
    ...
```

找到规律了！我们发现：

每一次使用“Six '6'”替换“Six”，就会在“Six”的右边多出一个“6”
“Six”终将被“6”而不是“Six '6'”替换
也就是说，“Six”推导出的应该是：1 至有限多个“6”。写成语法就是：

```
    Six ::= '6' { '6' }
```

可见，我们成功的消除了左递归。现在，语法的推导就可以正常开始并进行下去，而不会出现无限循环的情况了。
